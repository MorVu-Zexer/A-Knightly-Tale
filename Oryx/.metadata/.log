!SESSION 2019-10-02 16:54:32.544 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-02 16:54:56.789
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-03 11:34:28.578 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-03 11:35:07.093
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-04 11:37:45.071 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-04 11:38:58.248
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-05 00:18:54.843 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2019-10-05 00:19:02.972
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2019-10-05 00:19:44.881
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-05 10:47:30.025 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-05 10:48:01.162
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-12 00:29:03.528 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-12 00:29:45.275
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-12 14:23:55.463 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-12 14:24:25.343
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-12 14:44:01.490 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-12 14:44:10.881
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-12 16:18:30.070 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-12 16:18:51.000
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-12 16:19:49.770 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-12 16:20:02.246
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-13 13:43:05.646 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-13 13:43:33.788
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-14 14:38:55.629 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-14 14:39:17.462
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-15 20:25:14.540 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2019-10-15 20:25:18.384
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2019-10-15 20:25:39.154
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-18 11:42:45.498 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-18 11:43:30.669
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-20 13:23:11.068 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-20 13:24:32.295
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-21 11:40:14.281 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2019-10-21 11:40:17.491
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2019-10-21 11:40:36.161
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-21 12:23:02.653 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-21 12:23:11.423
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-29 12:22:41.459 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2019-10-29 12:22:46.529
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2019-10-29 12:23:08.283
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-10-31 18:09:18.442 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-10-31 18:09:46.226
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-11-01 18:03:11.732 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-11-01 18:04:40.884
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-11-18 11:46:12.555 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-11-18 11:46:48.212
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-11-28 12:00:13.271 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2019-11-28 12:00:19.584
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2019-11-28 12:00:37.153
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-11-30 14:59:18.425 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-11-30 15:00:48.284
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-12-04 15:48:58.907 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-12-04 15:49:43.603
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-12-12 09:07:22.576 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-12-12 09:08:01.110
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-12-18 10:24:50.693 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2019-12-18 10:25:26.623
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2019-12-23 23:01:49.365 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2019-12-23 23:04:07.990
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2019-12-23 23:04:38.247
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-01-07 23:42:12.646 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-01-07 23:44:09.888
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2020-01-07 23:44:46.572
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-01-09 12:12:12.014 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-01-09 12:12:30.567
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2020-01-09 12:12:53.330
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-01-12 04:56:18.036 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-01-12 04:57:11.349
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-01-13 01:23:04.822 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-01-13 01:23:53.053
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-01-14 07:34:44.750 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-01-14 07:35:48.388
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-01-14 12:29:14.793 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-01-14 12:29:57.935
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2020-01-14 12:30:52.322
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2020-01-15 05:09:10.323
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.ArrayIndexOutOfBoundsException: 283
	at java.util.Arrays$ArrayList.get(Unknown Source)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.selectProposal(CompletionProposalPopup.java:1429)
	at org.eclipse.jface.text.contentassist.CompletionProposalPopup.verifyKey(CompletionProposalPopup.java:1367)
	at org.eclipse.jface.text.contentassist.ContentAssistant$InternalListener.verifyKey(ContentAssistant.java:809)
	at org.eclipse.jface.text.TextViewer$VerifyKeyListenersManager.verifyKey(TextViewer.java:480)
	at org.eclipse.swt.custom.StyledTextListener.handleEvent(StyledTextListener.java:70)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.notifyListeners(Widget.java:780)
	at org.eclipse.swt.custom.StyledText.handleKeyDown(StyledText.java:6101)
	at org.eclipse.swt.custom.StyledText.lambda$1(StyledText.java:5795)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1108)
	at org.eclipse.swt.widgets.Widget.sendKeyEvent(Widget.java:1104)
	at org.eclipse.swt.widgets.Widget.wmKeyDown(Widget.java:1759)
	at org.eclipse.swt.widgets.Control.WM_KEYDOWN(Control.java:5146)
	at org.eclipse.swt.widgets.Canvas.WM_KEYDOWN(Canvas.java:414)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4793)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3583)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.jdt.debug 2 0 2020-01-15 05:43:15.084
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread
!SESSION 2020-01-15 11:52:31.402 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2020-01-15 11:52:40.519
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2020-01-15 11:52:40.519
!MESSAGE Could not read metadata for 'Project Requiem'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Project Requiem)[567]: java.lang.Exception: The project description file (.project) for 'Project Requiem' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1557)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2454)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2211)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:489)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:842)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:834)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:791)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1015)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:603)
	at org.eclipse.osgi.container.Module.start(Module.java:467)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:493)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:571)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:330)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:398)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:472)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:425)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:417)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:155)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:151)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2020-01-15 11:52:40.536
!MESSAGE The project description file (.project) for 'Project Requiem' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Project Requiem' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1557)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2454)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2211)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:489)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:842)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:834)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:791)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1015)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:603)
	at org.eclipse.osgi.container.Module.start(Module.java:467)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:493)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:571)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:330)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:398)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:472)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:425)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:417)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:155)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:151)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.egit.ui 2 0 2020-01-15 11:52:58.253
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 567 2020-01-15 11:53:19.631
!MESSAGE The project description file (.project) for 'Project Requiem' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Project Requiem' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1056)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1102)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.ui.ide 4 4 2020-01-17 11:49:40.057
!MESSAGE Problems saving workspace

!ENTRY org.eclipse.ui.ide 2 1 2020-01-17 11:49:40.224
!MESSAGE Problems occurred while trying to save the state of the workbench.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2020-01-17 11:49:40.224
!MESSAGE The project description file (.project) for 'Project Requiem' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.

!ENTRY org.eclipse.core.resources 2 10035 2020-01-17 11:49:45.658
!MESSAGE The workspace will exit with unsaved changes in this session.
!SESSION 2020-01-17 11:39:04.519 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-01-17 11:50:09.428
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 4 2 2020-01-20 12:10:35.515
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:524)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:232)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:240)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:94)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:68)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at sun.reflect.GeneratedMethodAccessor42.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:993)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:966)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2110)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1741)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.Workbench$10.run(Workbench.java:1125)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1108)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1409)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1409)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1385)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1737)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1775)
	at org.eclipse.ui.internal.WorkbenchWindow$3.close(WorkbenchWindow.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:577)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:284)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1573)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4763)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3583)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2020-01-20 12:10:35.607
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:524)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:232)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:240)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:94)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:68)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at sun.reflect.GeneratedMethodAccessor42.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:993)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:966)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2110)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1741)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.Workbench$10.run(Workbench.java:1125)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1108)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1409)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1409)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1385)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1737)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1775)
	at org.eclipse.ui.internal.WorkbenchWindow$3.close(WorkbenchWindow.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:577)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:284)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1573)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4763)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3583)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SESSION 2020-01-20 12:19:35.186 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-01-20 12:20:09.375
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-01-22 20:31:41.156 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-01-22 20:32:17.255
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-01-25 09:52:08.841 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 4 567 2020-01-25 09:52:22.405
!MESSAGE Workspace restored, but some problems occurred.
!SUBENTRY 1 org.eclipse.core.resources 4 567 2020-01-25 09:52:22.405
!MESSAGE Could not read metadata for 'Project Caliburn 2'.
!STACK 1
org.eclipse.core.internal.resources.ResourceException(/Project Caliburn 2)[567]: java.lang.Exception: The project description file (.project) for 'Project Caliburn 2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1557)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2454)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2211)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:489)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:842)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:834)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:791)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1015)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:603)
	at org.eclipse.osgi.container.Module.start(Module.java:467)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:493)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:571)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:330)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:398)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:472)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:425)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:417)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:155)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:151)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SUBENTRY 2 org.eclipse.core.resources 4 567 2020-01-25 09:52:22.420
!MESSAGE The project description file (.project) for 'Project Caliburn 2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Project Caliburn 2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:868)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:724)
	at org.eclipse.core.internal.resources.SaveManager.startup(SaveManager.java:1557)
	at org.eclipse.core.internal.resources.Workspace.startup(Workspace.java:2454)
	at org.eclipse.core.internal.resources.Workspace.open(Workspace.java:2211)
	at org.eclipse.core.resources.ResourcesPlugin.start(ResourcesPlugin.java:489)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:842)
	at org.eclipse.osgi.internal.framework.BundleContextImpl$3.run(BundleContextImpl.java:1)
	at java.security.AccessController.doPrivileged(Native Method)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.startActivator(BundleContextImpl.java:834)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.start(BundleContextImpl.java:791)
	at org.eclipse.osgi.internal.framework.EquinoxBundle.startWorker0(EquinoxBundle.java:1015)
	at org.eclipse.osgi.internal.framework.EquinoxBundle$EquinoxModule.startWorker(EquinoxBundle.java:365)
	at org.eclipse.osgi.container.Module.doStart(Module.java:603)
	at org.eclipse.osgi.container.Module.start(Module.java:467)
	at org.eclipse.osgi.framework.util.SecureAction.start(SecureAction.java:493)
	at org.eclipse.osgi.internal.hooks.EclipseLazyStarter.postFindLocalClass(EclipseLazyStarter.java:117)
	at org.eclipse.osgi.internal.loader.classpath.ClasspathManager.findLocalClass(ClasspathManager.java:571)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.findLocalClass(ModuleClassLoader.java:330)
	at org.eclipse.osgi.internal.loader.BundleLoader.findLocalClass(BundleLoader.java:398)
	at org.eclipse.osgi.internal.loader.sources.SingleSourcePackage.loadClass(SingleSourcePackage.java:41)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClassInternal(BundleLoader.java:472)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:425)
	at org.eclipse.osgi.internal.loader.BundleLoader.findClass(BundleLoader.java:417)
	at org.eclipse.osgi.internal.loader.ModuleClassLoader.loadClass(ModuleClassLoader.java:155)
	at java.lang.ClassLoader.loadClass(Unknown Source)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:151)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.egit.ui 2 0 2020-01-25 09:52:45.174
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 567 2020-01-25 09:53:00.722
!MESSAGE The project description file (.project) for 'Project Caliburn 2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Project Caliburn 2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1056)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1102)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2020-01-25 09:55:48.602 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-01-25 09:55:57.153
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug 2 0 2020-01-26 21:23:54.086
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread
!SESSION 2020-01-26 21:26:45.361 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-01-26 21:27:19.901
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-04-20 09:25:05.595 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-04-20 09:25:24.766
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2020-04-20 09:25:54.592
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-04-23 09:17:13.710 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2020-04-23 09:17:25.987
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2020-04-23 09:18:00.002
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-08-04 15:42:06.809 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-08-04 15:43:55.410
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-09-18 14:34:15.701 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-09-18 14:34:56.981
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.747
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.754
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.760
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.766
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.773
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.780
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.786
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.798
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.809
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.814
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 15:42:23.838
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 16:55:24.385
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 16:55:24.394
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.ui 4 0 2020-09-18 16:55:24.431
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.UnsupportedOperationException: Operation only supported in ASTs with previewEnabled flag as true
	at org.eclipse.jdt.core.dom.ASTNode.unsupportedWithoutPreviewError(ASTNode.java:2131)
	at org.eclipse.jdt.core.dom.SwitchCase.expressions(SwitchCase.java:281)
	at org.eclipse.jdt.internal.corext.dom.ASTFlattener.visit(ASTFlattener.java:1548)
	at org.eclipse.jdt.core.dom.SwitchCase.accept0(SwitchCase.java:234)
	at org.eclipse.jdt.core.dom.ASTNode.accept(ASTNode.java:2874)
	at org.eclipse.jdt.internal.corext.dom.ASTNodes.asString(ASTNodes.java:157)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.findSwitchCaseTarget(JavaElementHyperlinkDetector.java:280)
	at org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector.detectHyperlinks(JavaElementHyperlinkDetector.java:108)
	at org.eclipse.ui.texteditor.HyperlinkDetectorRegistry$HyperlinkDetectorDelegate.detectHyperlinks(HyperlinkDetectorRegistry.java:81)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:289)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.findHyperlinks(HyperlinkManager.java:262)
	at org.eclipse.jface.text.hyperlink.HyperlinkManager.mouseMove(HyperlinkManager.java:457)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:216)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:3986)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3585)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SESSION 2020-09-19 14:39:23.322 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2020-09-19 14:40:04.622
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2020-10-29 16:01:26.185 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.osgi 4 0 2020-10-29 16:02:13.916
!MESSAGE Application error
!STACK 1
org.eclipse.swt.SWTError: No more handles
	at org.eclipse.swt.SWT.error(SWT.java:4737)
	at org.eclipse.swt.SWT.error(SWT.java:4626)
	at org.eclipse.swt.SWT.error(SWT.java:4597)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:452)
	at org.eclipse.swt.widgets.Control.createHandle(Control.java:721)
	at org.eclipse.swt.widgets.Composite.createHandle(Composite.java:295)
	at org.eclipse.swt.widgets.Control.createWidget(Control.java:761)
	at org.eclipse.swt.widgets.Scrollable.createWidget(Scrollable.java:154)
	at org.eclipse.swt.widgets.Control.<init>(Control.java:115)
	at org.eclipse.swt.widgets.Scrollable.<init>(Scrollable.java:85)
	at org.eclipse.swt.widgets.Composite.<init>(Composite.java:99)
	at org.eclipse.ui.splash.BasicSplashHandler.getBundleProgressMonitor(BasicSplashHandler.java:136)
	at org.eclipse.ui.splash.BasicSplashHandler.getContent(BasicSplashHandler.java:231)
	at org.eclipse.ui.internal.splash.EclipseSplashHandler.init(EclipseSplashHandler.java:99)
	at org.eclipse.ui.internal.Workbench$2.run(Workbench.java:831)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.createSplashWrapper(Workbench.java:845)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:596)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SESSION 2021-01-10 07:45:08.067 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-10 07:45:36.627
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-12 14:04:44.300 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-12 14:05:25.787
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-19 15:38:52.315 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-19 15:39:46.751
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 567 2021-01-19 17:30:51.698
!MESSAGE The project description file (.project) for 'Project Caliburn 2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Project Caliburn 2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1056)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1102)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.ui 4 10001 2021-01-19 18:35:06.707
!MESSAGE Internal Error
!STACK 1
Java Model Exception: Java Model Status [setY(int) [in Enemies [in [Working copy] Enemies.java [in oryx [in src [in Oryx 2]]]]] does not exist]
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:573)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:614)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:326)
	at org.eclipse.jdt.internal.core.JavaElement.getElementInfo(JavaElement.java:312)
	at org.eclipse.jdt.internal.core.SourceRefElement.getSourceRange(SourceRefElement.java:233)
	at org.eclipse.jdt.internal.core.Member.getJavadocRange(Member.java:301)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContentFromSource(JavadocContentAccess2.java:664)
	at org.eclipse.jdt.internal.ui.text.javadoc.JavadocContentAccess2.getHTMLContent(JavadocContentAccess2.java:540)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:760)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:678)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:670)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:167)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:133)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$4.run(TextViewerHoverManager.java:169)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2021-01-19 18:35:06.720
!MESSAGE setY(int) [in Enemies [in [Working copy] Enemies.java [in oryx [in src [in Oryx 2]]]]] does not exist

!ENTRY org.eclipse.ui 4 4 2021-01-19 18:43:55.506
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.debug.internal.ui.sourcelookup.Prompter$$Lambda$519/1093667940@923c5f1, thread Worker-73: Launching Oryx (1) will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2021-01-19 18:43:55.506
!MESSAGE Worker-73: Launching Oryx (1) thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread Worker-73: Launching Oryx (1)
	at sun.management.ThreadImpl.dumpThreads0(Native Method)
	at sun.management.ThreadImpl.getThreadInfo(Unknown Source)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:209)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:179)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:155)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4622)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.handleStatus(Prompter.java:81)
	at org.eclipse.debug.core.model.LaunchConfigurationDelegate.saveBeforeLaunch(LaunchConfigurationDelegate.java:246)
	at org.eclipse.debug.core.model.LaunchConfigurationDelegate.preLaunchCheck(LaunchConfigurationDelegate.java:198)
	at org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.preLaunchCheck(AbstractJavaLaunchConfigurationDelegate.java:1020)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:823)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:719)
	at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1017)
	at org.eclipse.debug.internal.ui.DebugUIPlugin$2.run(DebugUIPlugin.java:1220)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.ui 4 4 2021-01-19 18:43:55.506
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at java.lang.Object.wait(Native Method)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:318)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:205)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:297)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2243)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2290)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2322)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.validateState(TextFileDocumentProvider.java:1037)
	at org.eclipse.ui.texteditor.AbstractTextEditor.validateState(AbstractTextEditor.java:4951)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1322)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7182)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveablesList.lambda$2(SaveablesList.java:850)
	at org.eclipse.ui.internal.SaveablesList$$Lambda$681/330947072.run(Unknown Source)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.ui.internal.SaveableHelper$$Lambda$682/1296193650.run(Unknown Source)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:2368)
	at org.eclipse.ui.internal.WorkbenchWindow$$Lambda$479/1631120910.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2366)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:858)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:822)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3451)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1495)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1483)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter$$Lambda$519/1093667940.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.ui.internal.UISynchronizer.lambda$0(UISynchronizer.java:152)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$440/604143480.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3961)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3588)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.ui.internal.Workbench$$Lambda$26/17808347.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SESSION 2021-01-22 12:18:51.292 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-22 12:19:37.438
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-22 12:30:40.144 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -data C:\Users\battl\eclipse-workspace -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-22 12:30:49.341
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-01-22 16:54:38.256
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package oryx;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

import javax.swing.Timer;

import enemies.Hugsbert;
import enemies.MadMask;
import enemies.MudMuk;
import enemies.SpyEye;

import javax.imageio.ImageIO;
import javax.swing.JPanel;

public class Display extends JPanel implements ActionListener, MouseListener, MouseMotionListener {

	// String path = System.getProperty("home.dir");

	/*
	 * SpyEye - fires in all directions MudMuk - fires straight at the player in a
	 * shotgun pattern Hugsbert - predicts where the player will be MadMask -
	 * periodically rapid fires at the player
	 */

	Oryx oryx = new Oryx();
	Player player = new Player
	ArrayList<Enemies> enemy = new ArrayList<Enemies>();
	
	ArrayList<PowerUp> powerUp = new ArrayList<PowerUp>();

	int x = (oryx.frame.getWidth() / 2) - 10, y = (oryx.frame.getHeight() / 2) - 10;
	int locationX = x, locationY = y;
	int movementTrackerX = 0, movementTrackerY = 0;

	boolean playerAlive = true;
	int playerHP = 100;
	boolean up = false, down = false, left = false, right = false;
	boolean shooting = false;

	boolean ability = false;
	double mana = 100;

	int regen = 0;
	int regenUp = 0;
	int manaUp = 0;
	int damageUp = 0;
	int defenseUp = 0;
	int powerUpAnimation = 0;

	int shootingCounter = 0;

	int hiScore, killCount = 0;

	int mouseX = 0, mouseY = 0;

	int barrierX = -2000, barrierY = -2000, barrierW = 5000, barrierH = 5000;

	int spawnRate;

	String[] enemyNames = { "SpyEye", "MudMuk", "Hugsbert", "MadMask" };
	
	Random random = new Random();

	ArrayList<Boolean> playerShot = new ArrayList<Boolean>();
	ArrayList<Integer> bulletLife = new ArrayList<Integer>();
	ArrayList<Double> bulletX = new ArrayList<Double>();
	ArrayList<Double> bulletY = new ArrayList<Double>();
	ArrayList<Double> bulletXAngle = new ArrayList<Double>();
	ArrayList<Double> bulletYAngle = new ArrayList<Double>();
	ArrayList<Double> bulletAimAngle = new ArrayList<Double>();

//	ArrayList<String> powerUpType = new ArrayList<String>();
//	ArrayList<Integer> powerUpX = new ArrayList<Integer>();
//	ArrayList<Integer> powerUpY = new ArrayList<Integer>();

	ArrayList<Integer> gravesX = new ArrayList<Integer>();
	ArrayList<Integer> gravesY = new ArrayList<Integer>();

	
//	ArrayList<String> enemyName = new ArrayList<String>();
//	ArrayList<Boolean> enemyAlive = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShot = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShooting = new ArrayList<Boolean>();
//	ArrayList<Double> enemyX = new ArrayList<Double>();
//	ArrayList<Double> enemyY = new ArrayList<Double>();
//	ArrayList<Double> enemyW = new ArrayList<Double>();
//	ArrayList<Double> enemyH = new ArrayList<Double>();
//	ArrayList<String> enemyBulletOrigin = new ArrayList<String>();
//	ArrayList<Double> enemyBulletX = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletY = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletW = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletH = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletXAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletYAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletAimAngle = new ArrayList<Double>();
//	ArrayList<Integer> enemyBulletLife = new ArrayList<Integer>();
//	ArrayList<Double> enemyBulletSpeed = new ArrayList<Double>();
//	ArrayList<Integer> enemyShootingCounter = new ArrayList<Integer>();
//	ArrayList<Integer> enemyHP = new ArrayList<Integer>();
//	ArrayList<Integer> enemyDirectionCounter = new ArrayList<Integer>();
//	ArrayList<Double> movementAngleX = new ArrayList<Double>();
//	ArrayList<Double> movementAngleY = new ArrayList<Double>();

	ArrayList<Double> storedX = new ArrayList<Double>();
	ArrayList<Double> storedY = new ArrayList<Double>();
	ArrayList<Double> storedX2 = new ArrayList<Double>();
	ArrayList<Double> storedY2 = new ArrayList<Double>();
	ArrayList<Double> predictiveAimAngle = new ArrayList<Double>();

	Timer t;

	AffineTransform at = new AffineTransform();
	
	BufferedImage playerBullet = null;
	BufferedImage madMaskBullet = null;
	BufferedImage SpyEyeBullet = null;
	BufferedImage HugsbertBullet = null;
	BufferedImage MudMukBullet = null;
	
	// Image player = Toolkit.getDefaultToolkit().getImage(path +
	// "/src/images/BulletHellShip.png");

	public Display() throws IOException {
		initComponents();
		t = new Timer(1, this);
		t.start();

		previousDeaths();
		
		bufferImages();
	}

	public void	bufferImages() {
		try {
		    playerBullet = ImageIO.read(new File("src/images/OryxBullet1.png"));
		} catch (IOException e) { 
		}
		try {
		    madMaskBullet = ImageIO.read(new File("src/images/MadMaskBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    SpyEyeBullet = ImageIO.read(new File("src/images/SpyEyeBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    HugsbertBullet = ImageIO.read(new File("src/images/HugsbertBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    MudMukBullet = ImageIO.read(new File("src/images/MudMukBullet.png"));
		} catch (IOException e) { 
		}
	}
	
	public void highScoreWriter(int highScore) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/hiScore.txt");
		Scanner s = new Scanner(file);
		String line;
		line = s.nextLine();
		highScore = Integer.parseInt(line);
		if (killCount > highScore) {
			highScore = killCount;
			FileWriter output = new FileWriter(file);
			output.write(new Integer(highScore).toString());
			output.close();
		}
		this.hiScore = highScore;
	}

	public void previousDeaths() throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		Scanner s = new Scanner(file);
		if (s.hasNextLine()) {
			String line = s.nextLine();
			String[] coordinates = line.split(" ");
			for (int i = 0; i < coordinates.length; i++) {
				String[] chopped = coordinates[i].split(",");
				gravesX.add(Integer.parseInt(chopped[0]));
				gravesY.add(Integer.parseInt(chopped[1]));
			}
		}

		// while (s.hasNext()) {
		// line = s.nextLine();
		// chopped = line.split(", ");
		// gravesX.add(Integer.parseInt(chopped[0]));
		// gravesY.add(Integer.parseInt(chopped[1]));
		// }
		s.close();
	}

	public void recordDeath(int x, int y) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		FileWriter output = new FileWriter(file);
		for (int i = 0; i < gravesX.size(); i++) {
			output.write(new Integer(gravesX.get(i) + movementTrackerX).toString());
			output.write(",");
			output.write(new Integer(gravesY.get(i) + movementTrackerY).toString());
			output.write(" ");
		}
		output.write(new Integer(x).toString());
		output.write(",");
		output.write(new Integer(y).toString());
		output.write(" ");
		output.close();
	}

	public void drawPreviousDeaths(Graphics g) {
		int[] gravesX2 = new int[gravesX.size()];
		int[] gravesY2 = new int[gravesY.size()];
		for (int i = 0; i < gravesX.size(); i++) {
			gravesX2[i] = gravesX.get(i);
			gravesY2[i] = gravesY.get(i);
			drawDeadPlayer(gravesX2[i], gravesY2[i], g);
		}
	}
	
	public void spawning() {
		
		spawnRate = random.nextInt(500) + 1;

		if (spawnRate == 500) {
			double spawnPointX = random.nextInt((barrierX + barrierW) - 100) + barrierX + 100;
			double spawnPointY = random.nextInt((barrierY + barrierH) - 100) + barrierY + 100;

			String name = enemyNames[random.nextInt(4)];
			
//			0 - SpyEye
//			1 - MudMuk
//			2 - Hugsbert
//			3 - MadMask
			
			switch (name) {
				case "SpyEye" : {
					enemy.add(new SpyEye(spawnPointX, spawnPointY));
					break;
				}
				case "MudMuk" : {
					enemy.add(new MudMuk(spawnPointX, spawnPointY));
					break;
				}
				case "Hugsbert" : {
					enemy.add(new Hugsbert(spawnPointX, spawnPointY));
					break;
				}
				case "MadMask" : {
					enemy.add(new MadMask(spawnPointX, spawnPointY));
					break;
				}
			}
			
//			enemyAlive.add(true);
//			enemyName.add(enemyNames[random.nextInt(4)]);
//			enemyX.add(spawnPointX);
//			enemyY.add(spawnPointY);
//			predictiveAimAngle.add(0.0);
//			enemyShootingCounter.add(0);
//			for (int i = 0; i < enemyAlive.size(); i++) {
//				if (enemyName.get(i) == "SpyEye") {
//					enemyW.add(210.0);
//					enemyH.add(140.0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					enemyW.add(180.0);
//					enemyH.add(160.0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					enemyW.add(156.0);
//					enemyH.add(168.0);
//				} else if (enemyName.get(i) == "MadMask") {
//					enemyW.add(144.0);
//					enemyH.add(160.0);
//				}
//				if (enemyAlive.size() > enemyHP.size() && i == enemyHP.size()) {
//					if (enemyName.get(i) == "SpyEye") {
//						enemyHP.add(500);
//					} else if (enemyName.get(i) == "MudMuk") {
//						enemyHP.add(700);
//					} else if (enemyName.get(i) == "Hugsbert") {
//						enemyHP.add(600);
//					} else if (enemyName.get(i) == "MadMask") {
//						enemyHP.add(500);
//					}
//				}
//			}
		}
	}

	public void drawDeadPlayer(int x, int y, Graphics g) {
		int[] graveX = { x + 4, x + 4, x + 20, x + 20, x + 24, x + 24, x, x };
		int[] graveY = { y + 4, y, y, y + 4, y + 4, y + 28, y + 28, y + 4 };
		Color graveGray = new Color(200, 200, 200);
		g.setColor(graveGray);
		g.fillRect(x, y + 4, 4, 24);
		g.fillRect(x + 4, y, 4, 28);
		g.fillRect(x + 8, y, 4, 28);
		g.fillRect(x + 12, y, 4, 28);
		g.fillRect(x + 16, y, 4, 28);
		Color graveShade = new Color(152, 152, 152);
		g.setColor(graveShade);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 4, y + 16, 12, 4);
		g.fillRect(x + 16, y, 4, 4);
		g.fillRect(x + 20, y + 4, 4, 24);
		g.setColor(Color.BLACK);
		g.drawPolygon(graveX, graveY, 8);
	}

	public void drawBullets(Graphics g, Graphics2D g2d) {
		for (int i = 0; i < playerShot.size(); i++) {
			double[] bulletX2 = new double[bulletX.size()];
			double[] bulletY2 = new double[bulletY.size()];
			bulletX2[i] = bulletX.get(i);
			bulletY2[i] = bulletY.get(i);
			
			at.rotate(-bulletAimAngle.get(i), bulletX2[i] + ((playerBullet.getWidth()*4)/2), bulletY2[i] + ((playerBullet.getHeight()*4) /2));
			g2d.transform(at);
			g2d.drawImage(playerBullet, (int) bulletX2[i] + 5, (int) bulletY2[i] + 5, 12, 20, null);
			
			try{
		        g2d.transform(at.createInverse());
		    }catch(NoninvertibleTransformException e){
		        //...
		    }
			
			at.setToIdentity();
		}
	}

	public void drawEnemies(Graphics g) {
		
		for (int i = 0; i < enemy.size(); i++) {
			enemy.get(i).draw(g);
		}
//		g.setColor(Color.RED);
//
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double[] enemyX2 = new double[enemyX.size()];
//			double[] enemyY2 = new double[enemyY.size()];
//			enemyX2[i] = enemyX.get(i);
//			enemyY2[i] = enemyY.get(i);
//			if (enemyName.get(i) == "SpyEye") {
//	//			enemy.drawSpyEye((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//			} else if (enemyName.get(i) == "MudMuk") {
//	//			enemy.drawMudMuk((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//			} else if (enemyName.get(i) == "Hugsbert") {
//	//			enemy.drawHugsbert((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//			} else if (enemyName.get(i) == "MadMask") {
//	//			enemy.drawMadMask((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//			}
//			// g.fillRect((int) enemyX2[i], (int) enemyY2[i], 50, 50);
//		}
	}
	
//	public void drawMadMaskBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MadMask") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((madMaskBullet.getWidth()*4)/2), enemyBulletY2[i] + ((madMaskBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(madMaskBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    } catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				} 
//				
//				}
//			}
//	}
//
//	public void drawSpyEyeBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "SpyEye") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((SpyEyeBullet.getWidth()*4)/2), enemyBulletY2[i] + ((SpyEyeBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(SpyEyeBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawHugsbertBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "Hugsbert") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((HugsbertBullet.getWidth()*4)/2), enemyBulletY2[i] + ((HugsbertBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(HugsbertBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawMudMukBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MudMuk") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i), enemyBulletX2[i] + ((MudMukBullet.getWidth()*4)/2), enemyBulletY2[i] + ((MudMukBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(MudMukBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
	
	public void drawHealthUp(int x, int y, Graphics g) {
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 4, 4, 12);
		g.fillRect(x + 4, y, 8, 4);
		g.fillRect(x + 4, y + 16, 4, 4);
		g.fillRect(x + 8, y + 20, 4, 4);
		g.fillRect(x + 12, y + 4, 4, 4);
		g.fillRect(x + 12, y + 24, 4, 4);
		g.fillRect(x + 16, y, 8, 4);
		g.fillRect(x + 16, y + 20, 4, 4);
		g.fillRect(x + 20, y + 16, 4, 4);
		g.fillRect(x + 24, y + 4, 4, 12);
		g.setColor(Color.RED);
		g.fillRect(x + 4, y + 4, 4, 12);
		g.fillRect(x + 8, y + 4, 4, 16);
		g.fillRect(x + 12, y + 8, 4, 16);
		g.fillRect(x + 16, y + 4, 4, 16);
		g.fillRect(x + 20, y + 4, 4, 12);
		g.setColor(Color.WHITE);
		g.fillRect(x + 20, y + 4, 4, 4);
		for (int i = 0; i < powerUp.size(); i++) {
			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
		}
	}

	public void drawManaUp(int x, int y, Graphics g) {
		g.setColor(Color.BLUE);
		g.fillRect(x + 4, y + 4, 20, 20);
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 8, 4, 12);
		g.fillRect(x + 4, y + 4, 4, 4);
		g.fillRect(x + 4, y + 20, 4, 4);
		g.fillRect(x + 8, y, 12, 4);
		g.fillRect(x + 8, y + 24, 12, 4);
		g.fillRect(x + 20, y + 4, 4, 4);
		g.fillRect(x + 20, y + 20, 4, 4);
		g.fillRect(x + 24, y + 8, 4, 12);
		g.setColor(Color.WHITE);
		g.fillRect(x + 16, y + 8, 4, 4);
		for (int i = 0; i < powerUp.size(); i++) {
			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.BLUE, g);
		}
	}
	
	public void drawDamageUp(int x, int y, Graphics g) {
		g.setColor(Color.RED);
		g.fillRect(x + 4, y + 4, 20, 20);
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 4, 4, 16);
		g.fillRect(x + 4, y, 20, 4);
		g.fillRect(x + 4, y + 12, 12, 4);
		g.fillRect(x + 4, y + 20, 4, 8);
		g.fillRect(x + 4, y + 24, 20, 4);
		g.fillRect(x + 8, y, 4, 16);
		g.fillRect(x + 16, y, 4, 12);
		g.fillRect(x + 16, y + 8, 12, 4);
		g.fillRect(x + 24, y + 4, 4, 16);
		g.fillRect(x + 16, y + 16, 4, 4);
		g.fillRect(x + 20, y + 20, 4, 4);
		for (int i = 0; i < powerUp.size(); i++) {
			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
		}
	}
	
	public void drawDefenseUp(int x, int y, Graphics g) {
		g.setColor(Color.BLACK);
		g.fillRect(x, y, 4, 16);
		g.fillRect(x, y, 32, 4);
		g.fillRect(x + 4, y + 16, 4, 4);
		g.fillRect(x + 8, y + 20, 4, 4);
		g.fillRect(x + 12, y + 24, 8, 4);
		g.fillRect(x + 20, y + 20, 4, 4);
		g.fillRect(x + 24, y + 16, 4, 4);
		g.fillRect(x + 28, y, 4, 16);
		Color shieldShade = new Color(130, 130, 130);
		g.setColor(shieldShade);
		g.fillRect(x + 4, y + 4, 12, 12);
		g.fillRect(x + 8, y + 16, 8, 4);
		g.fillRect(x + 12, y + 20, 4, 4);
		Color shield = new Color(201, 201, 201);
		g.setColor(shield);
		g.fillRect(x + 16, y + 20, 4, 4);
		g.fillRect(x + 16, y + 16, 8, 4);
		g.fillRect(x + 16, y + 4, 12, 12);
		for (int i = 0; i < powerUp.size(); i++) {
			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, shield, g);
		}
	}
	
	public void drawPowerUpArrow(int x, int y, int counter, Color color, Graphics g) {
		if (counter > 500 && counter < 1000) {
			y += 4;
		}
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 8, 4, 4);
		g.fillRect(x + 4, y + 4, 4, 4);
		g.fillRect(x + 4, y + 12, 4, 12);
		g.fillRect(x + 8, y, 4, 4);
		g.fillRect(x + 8, y + 20, 4, 4);
		g.fillRect(x + 12, y + 4, 4, 4);
		g.fillRect(x + 12, y + 12, 4, 12);
		g.fillRect(x + 16, y + 8, 4, 4);
		g.setColor(color);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 8, y + 4, 4, 16);
	}

	public void movement() {
		if (up == true) {
			if (y > barrierY) {
				barrierY++;
				locationY--;
				movementTrackerY--;

				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, 1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, 1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(1 + powerUp.get(i).getY());
				}
			}
		}

		if (down == true) {
			// y++;
			if (y < barrierY + barrierH - 20) {
				barrierY--;
				locationY++;
				movementTrackerY++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, -1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, -1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(-1 + powerUp.get(i).getY());
				}
			}
		}
		if (left == true) {
			//x--;
			if (x > barrierX) {
				barrierX++;
				locationX--;
				movementTrackerX--;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, 1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesX.set(i, 1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(1 + powerUp.get(i).getX());
				}
			}
		}
		if (right == true) {
			// x++;
			if (x < barrierX + barrierW - 20) {
				barrierX--;
				locationX++;
				movementTrackerX++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, -1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesX.size(); i++) {
					gravesX.set(i, -1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(-1 + powerUp.get(i).getX());
				}
			}
		}

		for (int i = 0; i < playerShot.size(); i++) {
			if (up) {
				bulletY.set(i, 1 + bulletY.get(i));
			}
			if (down) {
				bulletY.set(i, -1 + bulletY.get(i));
			}
			if (left) {
				bulletX.set(i, 1 + bulletX.get(i));
			}
			if (right) {
				bulletX.set(i, -1 + bulletX.get(i));
			}
		}
	}

	public void shootingMechanic() {

		double angle = Math.atan2((x + 15) - mouseX, (y + 35) - mouseY);
		
		if (shooting == true) {
			shootingCounter++;
			if (shootingCounter == 1) {
				playerShot.add(true);
				bulletLife.add(950);
				bulletX.add((double) x);
				bulletY.add((double) y);
				bulletXAngle.add(Math.sin(angle));
				bulletYAngle.add(Math.cos(angle));
				bulletAimAngle.add(angle);
			}
			if (shootingCounter == 50)
				shootingCounter = 0;
		} else {
			shootingCounter = 0;
		}

		for (int i = 0; i < playerShot.size(); i++) {
			bulletLife.set(i, -5 + bulletLife.get(i));
			if (playerShot.get(i)) {
				bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
				bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
			}
			if (bulletLife.get(i) <= 0) {
				bulletCleanup(i);
			}
		}
		if (ability) {
			abilityMechanic();
		} else if (mana < 100) {
			mana += 0.025 + (manaUp * 0.00625);
		}
	}

	public void abilityMechanic() {
		mana = 0;
		for (int i = 0; i < 30; i++) {
			double angle = Math.toRadians(0 + (i * 12));
			bulletXAngle.add(Math.sin(angle));
			bulletYAngle.add(Math.cos(angle));
			bulletAimAngle.add(angle);
			playerShot.add(true);
			bulletLife.add(950);
			bulletX.add((double) mouseX);
			bulletY.add((double) mouseY);
		}
		ability = false;
	}

	public void enemyLogic() {
//
		for (int i = 0; i < enemy.size(); i++) {
			
			enemy.get(i).movement(x, y);
			
			enemy.get(i).aggro(x, y, 20, 20);
			
			for (int i2 = 0; i2 < playerShot.size(); i2++) {
				if (enemyHit(i, i2)) {
					bulletCleanup(i2);
					enemy.get(i).setHP((-10 - (damageUp * 2)) + enemy.get(i).getHP());
				}
			}
//			if (enemyAlive.size() > 0) {
//				enemyMovement(enemyX, enemyY, enemyW, enemyH, i);
//				predictiveAiming(i);
//			}
//
//			if (enemyAlive.size() > 100) {
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
			
			if (enemy.get(i).getHP() <= 0) {
				enemy.remove(i);
				killCount++;
			}
//
//			if (enemyHP.get(i) <= 0)
//				enemyAlive.set(i, false);
//			if (enemyAlive.get(i) == false) {
//					killCount++;
//					int powerUpSpawn = random.nextInt(11); //TODO
//					powerUp(powerUpSpawn, i);
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
		}
	}

//	public void enemyMovement(ArrayList<Double> x, ArrayList<Double> y, ArrayList<Double> w, ArrayList<Double> h,
//			int i) {
//		if (enemyAlive.size() > enemyDirectionCounter.size()) {
//			enemyDirectionCounter.add(0);
//		}
//		enemyDirectionCounter.set(i, 1 + enemyDirectionCounter.get(i));
//		if (enemyDirectionCounter.get(i) == 1) {
//			int direction = random.nextInt(359);
//			double angle = direction;
//			double angle2 = Math.atan2((enemyX.get(i) + 85) - (this.x - 10), (y.get(i) + 70) - this.y);
//			if (movementAngleX.size() < enemyAlive.size()) {
//				movementAngleX.add(Math.sin(angle));
//				movementAngleY.add(Math.cos(angle));
//			} else {
////				if (playerAlive && x.get(i) < 1000 && y.get(i) < 650 && 0 < x.get(i) + w.get(i)
////						&& 0 < y.get(i) + h.get(i)) {
//					movementAngleX.set(i, (Math.sin(angle) + Math.sin(angle2)));
//					movementAngleY.set(i, (Math.cos(angle) + Math.cos(angle2)));
////				} else {
////					movementAngleX.set(i, Math.sin(angle));
////					movementAngleY.set(i, Math.cos(angle));
////				}
//			}
//		}
//		if (enemyDirectionCounter.get(i) < 50) {
//			x.set(i, x.get(i) - movementAngleX.get(i) * 0.125);
//			y.set(i, y.g et(i) - movementAngleY.get(i) * 0.125);
//		} else if (enemyDirectionCounter.get(i) >= 50) {
//			enemyDirectionCounter.set(i, 0);
//		}
//	}

	public boolean enemyHit(int i, int i2) {
		if (enemy.size() > 0) {
			if (bulletX.get(i2) < (enemy.get(i).getX() + 130.0) + 40.0 && enemy.get(i).getX() + 40.0 < bulletX.get(i2) + 10
					&& bulletY.get(i2) < (enemy.get(i).getY() + 130.0) + 10 && enemy.get(i).getY() < bulletY.get(i2) + 10) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	public void bulletCleanup(int i) {
		playerShot.remove(i);
		bulletLife.remove(i);
		bulletX.remove(i);
		bulletY.remove(i);
		bulletXAngle.remove(i);
		bulletYAngle.remove(i);
		bulletAimAngle.remove(i);
	}

//	public void enemyBulletLogic() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double angle = Math.atan2((enemyX.get(i) + 85) - (x - 10), (enemyY.get(i) + 70) - y);
//			enemyShootingCounter.set(i, 1 + enemyShootingCounter.get(i));
//			if (enemyShootingCounter.get(i) == 400 && enemyName.get(i) == "SpyEye"
//					|| enemyShootingCounter.get(i) == 500 && enemyName.get(i) == "MudMuk"
//					|| enemyShootingCounter.get(i) == 450 && enemyName.get(i) == "Hugsbert"
//					|| enemyName.get(i) == "MadMask") {
//				if (enemyName.get(i) == "SpyEye") {
//					omnidirectionalPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					shotgunPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					predictiveAimAngle.set(i, predictiveAim(x, y, enemyX.get(i), enemyY.get(i), angle, i));
//					shotgunPattern(predictiveAimAngle.get(i), i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MadMask") {
//					if (enemyShootingCounter.get(i) == 50 || enemyShootingCounter.get(i) == 100
//							|| enemyShootingCounter.get(i) == 150 || enemyShootingCounter.get(i) == 200
//							|| enemyShootingCounter.get(i) == 250)
//						genericPattern(angle, i);
//					else if (enemyShootingCounter.get(i) == 450)
//						enemyShootingCounter.set(i, 0);
//				}
//			}
//		}
//		for (int i2 = 0; i2 < enemyShooting.size(); i2++) {
//			bulletMovement(i2);
//		}
//	}

//	public void bulletMovement(int i) {
//		enemyBulletLife.set(i, -1 + enemyBulletLife.get(i));
//		enemyBulletX.set(i, enemyBulletX.get(i) - enemyBulletXAngle.get(i) * enemyBulletSpeed.get(i));
//		enemyBulletY.set(i, enemyBulletY.get(i) - enemyBulletYAngle.get(i) * enemyBulletSpeed.get(i));
//
//		if (enemyBulletLife.get(i) <= 0 || enemyShot.get(i) == false) {
//			enemyBulletOrigin.remove(i);
//			enemyBulletX.remove(i);
//			enemyBulletY.remove(i);
//			enemyBulletW.remove(i);
//			enemyBulletH.remove(i);
//			enemyBulletXAngle.remove(i);
//			enemyBulletYAngle.remove(i);
//			enemyBulletAimAngle.remove(i);
//			enemyBulletSpeed.remove(i);
//			enemyShooting.remove(i);
//			enemyShot.remove(i);
//			enemyBulletLife.remove(i);
//		}
//	}

	public double predictiveAim(int x, int y, double ex, double ey, double angle, int i) {
		double calculationX = ((storedX.get(i) - storedX2.get(i)) * -1) * 50;
		double calculationY = ((storedY.get(i) - storedY2.get(i)) * -1) * 50;
		// System.out.println(i + ": "+ storedX.get(i));
		// System.out.println((i+1) + ": "+ storedX.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationX);
		// System.out.println(i + ": "+ storedY.get(i));
		// System.out.println((i+1) + ": "+ storedY.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationY);
		// System.out.println(calculationX + ", " + calculationY);
		angle = Math.atan2((ex + 85) - ((x - 10) + calculationX), (ey + 70) - ((y - 10) + calculationY));
		// System.out.println(Math.toDegrees(angle));
		return angle;
	}

//	public void predictiveAiming(int i) {
//		if (storedX.size() < enemyAlive.size()) {
//			storedX.add(i, (double) movementTrackerX);
//			storedY.add(i, (double) movementTrackerY);
//			storedX2.add(i, (double) movementTrackerX);
//			storedY2.add(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 445) {
//			storedX.set(i, (double) movementTrackerX);
//			storedY.set(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 449) {
//			storedX2.set(i, (double) movementTrackerX);
//			storedY2.set(i, (double) movementTrackerY);
//		}
//	}

//	public void genericPattern(double angle, int i) {
//		if (enemyName.get(i) == "MadMask") {
//			enemyShooting.add(true);
//			enemyShot.add(true);
//			enemyBulletOrigin.add("MadMask");
//			enemyBulletX.add(enemyX.get(i) + 59.5);
//			enemyBulletY.add(enemyY.get(i) + 63.5);
//			enemyBulletW.add(25.0);
//			enemyBulletH.add(25.0);
//			enemyBulletXAngle.add(Math.sin(angle));
//			enemyBulletYAngle.add(Math.cos(angle));
//			enemyBulletAimAngle.add(angle);
//			enemyBulletLife.add(500);
//			enemyBulletSpeed.add(2.0);
//		}
//	}

//	public void shotgunPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "MudMuk") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("MudMuk");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2))));
//				enemyBulletSpeed.add(1.6);
//				enemyBulletLife.add(150);
//			}
//			if (enemyName.get(i) == "Hugsbert") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("Hugsbert");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2))));
//				enemyBulletSpeed.add(1.75);
//				enemyBulletLife.add(250);
//			}
//			// TODO - figure out how to do predictive aim
//		}
//	}

//	public void omnidirectionalPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "SpyEye") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("SpyEye");
//				enemyBulletX.add(enemyX.get(i) + 90);
//				enemyBulletY.add(enemyY.get(i) + 65);
//				enemyBulletW.add(30.0);
//				enemyBulletH.add(30.0);
//				enemyBulletXAngle.add(Math.sin(angle + Math.toRadians(72 * i2)));
//				enemyBulletYAngle.add(Math.cos(angle + Math.toRadians(72 * i2)));
//				enemyBulletAimAngle.add(angle + Math.toRadians(72 * i2));
//				enemyBulletSpeed.add(2.5);
//				enemyBulletLife.add(200);
//			}
//		}
//	}

//	public void bulletCollision() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			for (int i2 = i * 5; i2 >= i * 5 && i2 < (i * 5) + 5 && i2 < enemyShooting.size(); i2++) {
//				if (enemyBulletX.get(i2) < x + 20 && x < enemyBulletX.get(i2) + enemyBulletW.get(i2)
//						&& enemyBulletY.get(i2) < y + 20 && y < enemyBulletY.get(i2) + enemyBulletH.get(i2)) {
//					if (enemyName.get(i) == "SpyEye") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MudMuk") {
//						if ((defenseUp / 4) < 2) {
//							playerHP -= 2 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "Hugsbert") {
//						if ((defenseUp / 4) < 10) {
//							playerHP -= 10 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MadMask") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					}
//					enemyShot.set(i2, false);
//				}
//			}
//		}
//	}

//	public void powerUp(int spawnRate, int i) {
//
//		if (spawnRate == 0 || spawnRate == 1) {
//			powerUp.add(true);
//			powerUpType.add("Health");
//		} else if (spawnRate == 2 || spawnRate == 3) {
//			powerUp.add(true);
//			powerUpType.add("Mana");
//		} else if (spawnRate == 4) {
//			powerUp.add(true);
//			powerUpType.add("Damage");
//		} else if (spawnRate == 5) {
//			powerUp.add(true);
//			powerUpType.add("Defense");
//		}
//		for (int i2 = 0; i2 < powerUp.size(); i2++) {
//			if (powerUp.get(i2) && powerUp.size() > powerUpX.size() && i2 == powerUpX.size()) {
//				int[] enemyX2 = new int[enemyX.size()];
//				int[] enemyY2 = new int[enemyY.size()];
//				enemyX2[i] += enemyX.get(i) + (enemyW.get(i) / 2) - 12;
//				enemyY2[i] += enemyY.get(i) + (enemyH.get(i) / 2) - 12;
//				powerUpX.add(enemyX2[i]);
//				powerUpY.add(enemyY2[i]);
//				// if (powerUp.get(i2) == false) {
//				// powerUpX.remove(i2);
//				// powerUpY.remove(i2);
//				// powerUp.remove(i2);
//				// }
//			}
//		}
//	}

//	public boolean powerUpCollected(int i) {
//		if (x < powerUpX.get(i) + 44 && y < powerUpY.get(i) + 24 && powerUpX.get(i) < x + 24
//				&& powerUpY.get(i) < y + 20) {
//			return true;
//		} else {
//			return false;
//		}
//	}
	
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		
		Graphics2D g2d = (Graphics2D)g;
		
//		drawPowerUpArrow(500, 10, powerUpAnimation, (Color.RED), g);
		
		powerUpAnimation++;
		if (powerUpAnimation == 1000)
			powerUpAnimation = 0;
		for (int i = 0; i < powerUp.size(); i++) {
			powerUp.get(i).draw(g);
//			if (powerUpType.get(i) == "Health")
//				drawHealthUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Mana")
//				drawManaUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Damage")
//				drawDamageUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Defense")
//				drawDefenseUp(powerUpX.get(i), powerUpY.get(i), g);
		}

		drawPreviousDeaths(g);

		g.drawRect(barrierX, barrierY, barrierW, barrierH);

		
		
		drawEnemies(g);
//		
//		for (int i = 0; i < enemyName.size(); i++) {
//			if (enemyName.get(i) == "MadMask") {
//				drawMadMaskBullets(g, g2d);
//			} else if (enemyName.get(i) == "SpyEye") {
//				drawSpyEyeBullets(g, g2d);
//			} else if (enemyName.get(i) == "Hugsbert") {
//				drawHugsbertBullets(g, g2d);
//			} else {
//				drawMudMukBullets(g, g2d);
//			}
//		}

		if (playerAlive) {
			drawPlayer(x, y, g);
		} else {
			drawDeadPlayer(x, y, g);
		}

		g.drawString("Personal Best: " + hiScore, 10, 20);
		g.drawString("Kill Count: " + killCount, 10, 40);

		g.drawString("Enemies Alive: " + enemy.size(), 10, 65);
		g.drawString("Regen: " + regenUp, 10, 85);
		g.drawString("Mana Regen: " + manaUp, 10, 105);
		g.drawString("Damage: " + damageUp, 10, 125);
		g.drawString("Defense: " + defenseUp, 10, 145);
		
		drawBullets(g, g2d);
	}
	
	@Override
	public void actionPerformed(ActionEvent e) {
		
		spawning();
		
//		if (manaUp > 20) manaUp = 20; //mana cap


		
		regen++;
		if (regen > (300 - (regenUp * 5)) && playerHP < 100) {
			playerHP += 2 + regenUp;
			regen = 0;
		}
		if (playerHP > 100) {
			playerHP = 100;
		}
		for (int i = 0; i < powerUp.size(); i++) {
			if (powerUp.get(i).collected(player.getX(), y, w, h)) {
				if (powerUpType.get(i) == "Health")
					regenUp++;
				else if (powerUpType.get(i) == "Mana")
					manaUp++;
				else if (powerUpType.get(i) == "Damage") 
					damageUp++;
				else if (powerUpType.get(i) == "Defense") 
					defenseUp++;
				
				powerUpX.remove(i);
				powerUpY.remove(i);
				powerUp.remove(i);
				powerUpType.remove(i);
			}
		}

		if (playerHP <= 0) {
			playerAlive = false;
		}

		if (playerAlive) {
			movement();
			shootingMechanic();
//			bulletCollision();
		} else {
			for (int i = 0; i < playerShot.size(); i++) {
				bulletLife.set(i, -5 + bulletLife.get(i));
				if (playerShot.get(i)) {
					bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
					bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
				}
				if (bulletLife.get(i) <= 0) {
					bulletCleanup(i);
				}
			}
			try {
				recordDeath(locationX, locationY);
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

		enemyLogic();
//		enemyBulletLogic();
		
		try {
			highScoreWriter(hiScore);
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		

		repaint();
	}

	public void keyPressed(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = true;
		}
		if (key == 'A') {
			left = true;
		}
		if (key == 'S') {
			down = true;
		}
		if (key == 'D') {
			right = true;
		}
		if (key == KeyEvent.VK_SPACE && mana >= 100) {
			ability = true;
		}
	}
	public void keyReleased(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = false;
		}
		if (key == 'A') {
			left = false;
		}
		if (key == 'S') {
			down = false;
		}
		if (key == 'D') {
			right = false;
		}
		if (key == KeyEvent.VK_SPACE && mana == 100) {
			ability = false;
		}
	}

	@Override
	public void mouseClicked(MouseEvent e) {
	}
	@Override
	public void mousePressed(MouseEvent e) {
		shooting = true;
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		shooting = false;
	}
	@Override
	public void mouseDragged(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseMoved(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseEntered(MouseEvent e) {

	}
	@Override
	public void mouseExited(MouseEvent e) {

	}

	private void initComponents() {
		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
		this.setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 400, Short.MAX_VALUE));
		layout.setVerticalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 300, Short.MAX_VALUE));
	}

}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-01-22 16:54:38.469
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-01-22 16:54:38.476
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-01-22 16:55:10.649
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package oryx;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

import javax.swing.Timer;

import enemies.Hugsbert;
import enemies.MadMask;
import enemies.MudMuk;
import enemies.SpyEye;

import javax.imageio.ImageIO;
import javax.swing.JPanel;

public class Display extends JPanel implements ActionListener, MouseListener, MouseMotionListener {

	// String path = System.getProperty("home.dir");

	/*
	 * SpyEye - fires in all directions MudMuk - fires straight at the player in a
	 * shotgun pattern Hugsbert - predicts where the player will be MadMask -
	 * periodically rapid fires at the player
	 */

	Oryx oryx = new Oryx();
	Player player = new Player((oryx.frame.getWidth() / 2) - 10, y = (oryx.frame.getHeight() / 2) - 10, );
	ArrayList<Enemies> enemy = new ArrayList<Enemies>();
	
	ArrayList<PowerUp> powerUp = new ArrayList<PowerUp>();

	int x = (oryx.frame.getWidth() / 2) - 10, y = (oryx.frame.getHeight() / 2) - 10;
	int locationX = x, locationY = y;
	int movementTrackerX = 0, movementTrackerY = 0;

	boolean playerAlive = true;
	int playerHP = 100;
	boolean up = false, down = false, left = false, right = false;
	boolean shooting = false;

	boolean ability = false;
	double mana = 100;

	int regen = 0;
	int regenUp = 0;
	int manaUp = 0;
	int damageUp = 0;
	int defenseUp = 0;
	int powerUpAnimation = 0;

	int shootingCounter = 0;

	int hiScore, killCount = 0;

	int mouseX = 0, mouseY = 0;

	int barrierX = -2000, barrierY = -2000, barrierW = 5000, barrierH = 5000;

	int spawnRate;

	String[] enemyNames = { "SpyEye", "MudMuk", "Hugsbert", "MadMask" };
	
	Random random = new Random();

	ArrayList<Boolean> playerShot = new ArrayList<Boolean>();
	ArrayList<Integer> bulletLife = new ArrayList<Integer>();
	ArrayList<Double> bulletX = new ArrayList<Double>();
	ArrayList<Double> bulletY = new ArrayList<Double>();
	ArrayList<Double> bulletXAngle = new ArrayList<Double>();
	ArrayList<Double> bulletYAngle = new ArrayList<Double>();
	ArrayList<Double> bulletAimAngle = new ArrayList<Double>();

//	ArrayList<String> powerUpType = new ArrayList<String>();
//	ArrayList<Integer> powerUpX = new ArrayList<Integer>();
//	ArrayList<Integer> powerUpY = new ArrayList<Integer>();

	ArrayList<Integer> gravesX = new ArrayList<Integer>();
	ArrayList<Integer> gravesY = new ArrayList<Integer>();

	
//	ArrayList<String> enemyName = new ArrayList<String>();
//	ArrayList<Boolean> enemyAlive = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShot = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShooting = new ArrayList<Boolean>();
//	ArrayList<Double> enemyX = new ArrayList<Double>();
//	ArrayList<Double> enemyY = new ArrayList<Double>();
//	ArrayList<Double> enemyW = new ArrayList<Double>();
//	ArrayList<Double> enemyH = new ArrayList<Double>();
//	ArrayList<String> enemyBulletOrigin = new ArrayList<String>();
//	ArrayList<Double> enemyBulletX = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletY = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletW = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletH = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletXAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletYAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletAimAngle = new ArrayList<Double>();
//	ArrayList<Integer> enemyBulletLife = new ArrayList<Integer>();
//	ArrayList<Double> enemyBulletSpeed = new ArrayList<Double>();
//	ArrayList<Integer> enemyShootingCounter = new ArrayList<Integer>();
//	ArrayList<Integer> enemyHP = new ArrayList<Integer>();
//	ArrayList<Integer> enemyDirectionCounter = new ArrayList<Integer>();
//	ArrayList<Double> movementAngleX = new ArrayList<Double>();
//	ArrayList<Double> movementAngleY = new ArrayList<Double>();

	ArrayList<Double> storedX = new ArrayList<Double>();
	ArrayList<Double> storedY = new ArrayList<Double>();
	ArrayList<Double> storedX2 = new ArrayList<Double>();
	ArrayList<Double> storedY2 = new ArrayList<Double>();
	ArrayList<Double> predictiveAimAngle = new ArrayList<Double>();

	Timer t;

	AffineTransform at = new AffineTransform();
	
	BufferedImage playerBullet = null;
	BufferedImage madMaskBullet = null;
	BufferedImage SpyEyeBullet = null;
	BufferedImage HugsbertBullet = null;
	BufferedImage MudMukBullet = null;
	
	// Image player = Toolkit.getDefaultToolkit().getImage(path +
	// "/src/images/BulletHellShip.png");

	public Display() throws IOException {
		initComponents();
		t = new Timer(1, this);
		t.start();

		previousDeaths();
		
		bufferImages();
	}

	public void	bufferImages() {
		try {
		    playerBullet = ImageIO.read(new File("src/images/OryxBullet1.png"));
		} catch (IOException e) { 
		}
		try {
		    madMaskBullet = ImageIO.read(new File("src/images/MadMaskBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    SpyEyeBullet = ImageIO.read(new File("src/images/SpyEyeBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    HugsbertBullet = ImageIO.read(new File("src/images/HugsbertBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    MudMukBullet = ImageIO.read(new File("src/images/MudMukBullet.png"));
		} catch (IOException e) { 
		}
	}
	
	public void highScoreWriter(int highScore) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/hiScore.txt");
		Scanner s = new Scanner(file);
		String line;
		line = s.nextLine();
		highScore = Integer.parseInt(line);
		if (killCount > highScore) {
			highScore = killCount;
			FileWriter output = new FileWriter(file);
			output.write(new Integer(highScore).toString());
			output.close();
		}
		this.hiScore = highScore;
	}

	public void previousDeaths() throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		Scanner s = new Scanner(file);
		if (s.hasNextLine()) {
			String line = s.nextLine();
			String[] coordinates = line.split(" ");
			for (int i = 0; i < coordinates.length; i++) {
				String[] chopped = coordinates[i].split(",");
				gravesX.add(Integer.parseInt(chopped[0]));
				gravesY.add(Integer.parseInt(chopped[1]));
			}
		}

		// while (s.hasNext()) {
		// line = s.nextLine();
		// chopped = line.split(", ");
		// gravesX.add(Integer.parseInt(chopped[0]));
		// gravesY.add(Integer.parseInt(chopped[1]));
		// }
		s.close();
	}

	public void recordDeath(int x, int y) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		FileWriter output = new FileWriter(file);
		for (int i = 0; i < gravesX.size(); i++) {
			output.write(new Integer(gravesX.get(i) + movementTrackerX).toString());
			output.write(",");
			output.write(new Integer(gravesY.get(i) + movementTrackerY).toString());
			output.write(" ");
		}
		output.write(new Integer(x).toString());
		output.write(",");
		output.write(new Integer(y).toString());
		output.write(" ");
		output.close();
	}

	public void drawPreviousDeaths(Graphics g) {
		int[] gravesX2 = new int[gravesX.size()];
		int[] gravesY2 = new int[gravesY.size()];
		for (int i = 0; i < gravesX.size(); i++) {
			gravesX2[i] = gravesX.get(i);
			gravesY2[i] = gravesY.get(i);
			drawDeadPlayer(gravesX2[i], gravesY2[i], g);
		}
	}
	
	public void spawning() {
		
		spawnRate = random.nextInt(500) + 1;

		if (spawnRate == 500) {
			double spawnPointX = random.nextInt((barrierX + barrierW) - 100) + barrierX + 100;
			double spawnPointY = random.nextInt((barrierY + barrierH) - 100) + barrierY + 100;

			String name = enemyNames[random.nextInt(4)];
			
//			0 - SpyEye
//			1 - MudMuk
//			2 - Hugsbert
//			3 - MadMask
			
			switch (name) {
				case "SpyEye" : {
					enemy.add(new SpyEye(spawnPointX, spawnPointY));
					break;
				}
				case "MudMuk" : {
					enemy.add(new MudMuk(spawnPointX, spawnPointY));
					break;
				}
				case "Hugsbert" : {
					enemy.add(new Hugsbert(spawnPointX, spawnPointY));
					break;
				}
				case "MadMask" : {
					enemy.add(new MadMask(spawnPointX, spawnPointY));
					break;
				}
			}
			
//			enemyAlive.add(true);
//			enemyName.add(enemyNames[random.nextInt(4)]);
//			enemyX.add(spawnPointX);
//			enemyY.add(spawnPointY);
//			predictiveAimAngle.add(0.0);
//			enemyShootingCounter.add(0);
//			for (int i = 0; i < enemyAlive.size(); i++) {
//				if (enemyName.get(i) == "SpyEye") {
//					enemyW.add(210.0);
//					enemyH.add(140.0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					enemyW.add(180.0);
//					enemyH.add(160.0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					enemyW.add(156.0);
//					enemyH.add(168.0);
//				} else if (enemyName.get(i) == "MadMask") {
//					enemyW.add(144.0);
//					enemyH.add(160.0);
//				}
//				if (enemyAlive.size() > enemyHP.size() && i == enemyHP.size()) {
//					if (enemyName.get(i) == "SpyEye") {
//						enemyHP.add(500);
//					} else if (enemyName.get(i) == "MudMuk") {
//						enemyHP.add(700);
//					} else if (enemyName.get(i) == "Hugsbert") {
//						enemyHP.add(600);
//					} else if (enemyName.get(i) == "MadMask") {
//						enemyHP.add(500);
//					}
//				}
//			}
		}
	}

	public void drawDeadPlayer(int x, int y, Graphics g) {
		int[] graveX = { x + 4, x + 4, x + 20, x + 20, x + 24, x + 24, x, x };
		int[] graveY = { y + 4, y, y, y + 4, y + 4, y + 28, y + 28, y + 4 };
		Color graveGray = new Color(200, 200, 200);
		g.setColor(graveGray);
		g.fillRect(x, y + 4, 4, 24);
		g.fillRect(x + 4, y, 4, 28);
		g.fillRect(x + 8, y, 4, 28);
		g.fillRect(x + 12, y, 4, 28);
		g.fillRect(x + 16, y, 4, 28);
		Color graveShade = new Color(152, 152, 152);
		g.setColor(graveShade);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 4, y + 16, 12, 4);
		g.fillRect(x + 16, y, 4, 4);
		g.fillRect(x + 20, y + 4, 4, 24);
		g.setColor(Color.BLACK);
		g.drawPolygon(graveX, graveY, 8);
	}

	public void drawBullets(Graphics g, Graphics2D g2d) {
		for (int i = 0; i < playerShot.size(); i++) {
			double[] bulletX2 = new double[bulletX.size()];
			double[] bulletY2 = new double[bulletY.size()];
			bulletX2[i] = bulletX.get(i);
			bulletY2[i] = bulletY.get(i);
			
			at.rotate(-bulletAimAngle.get(i), bulletX2[i] + ((playerBullet.getWidth()*4)/2), bulletY2[i] + ((playerBullet.getHeight()*4) /2));
			g2d.transform(at);
			g2d.drawImage(playerBullet, (int) bulletX2[i] + 5, (int) bulletY2[i] + 5, 12, 20, null);
			
			try{
		        g2d.transform(at.createInverse());
		    }catch(NoninvertibleTransformException e){
		        //...
		    }
			
			at.setToIdentity();
		}
	}

	public void drawEnemies(Graphics g) {
		
		for (int i = 0; i < enemy.size(); i++) {
			enemy.get(i).draw(g);
		}
//		g.setColor(Color.RED);
//
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double[] enemyX2 = new double[enemyX.size()];
//			double[] enemyY2 = new double[enemyY.size()];
//			enemyX2[i] = enemyX.get(i);
//			enemyY2[i] = enemyY.get(i);
//			if (enemyName.get(i) == "SpyEye") {
//	//			enemy.drawSpyEye((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//			} else if (enemyName.get(i) == "MudMuk") {
//	//			enemy.drawMudMuk((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//			} else if (enemyName.get(i) == "Hugsbert") {
//	//			enemy.drawHugsbert((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//			} else if (enemyName.get(i) == "MadMask") {
//	//			enemy.drawMadMask((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//			}
//			// g.fillRect((int) enemyX2[i], (int) enemyY2[i], 50, 50);
//		}
	}
	
//	public void drawMadMaskBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MadMask") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((madMaskBullet.getWidth()*4)/2), enemyBulletY2[i] + ((madMaskBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(madMaskBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    } catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				} 
//				
//				}
//			}
//	}
//
//	public void drawSpyEyeBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "SpyEye") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((SpyEyeBullet.getWidth()*4)/2), enemyBulletY2[i] + ((SpyEyeBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(SpyEyeBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawHugsbertBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "Hugsbert") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((HugsbertBullet.getWidth()*4)/2), enemyBulletY2[i] + ((HugsbertBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(HugsbertBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawMudMukBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MudMuk") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i), enemyBulletX2[i] + ((MudMukBullet.getWidth()*4)/2), enemyBulletY2[i] + ((MudMukBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(MudMukBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
	
	public void drawHealthUp(int x, int y, Graphics g) {
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 4, 4, 12);
		g.fillRect(x + 4, y, 8, 4);
		g.fillRect(x + 4, y + 16, 4, 4);
		g.fillRect(x + 8, y + 20, 4, 4);
		g.fillRect(x + 12, y + 4, 4, 4);
		g.fillRect(x + 12, y + 24, 4, 4);
		g.fillRect(x + 16, y, 8, 4);
		g.fillRect(x + 16, y + 20, 4, 4);
		g.fillRect(x + 20, y + 16, 4, 4);
		g.fillRect(x + 24, y + 4, 4, 12);
		g.setColor(Color.RED);
		g.fillRect(x + 4, y + 4, 4, 12);
		g.fillRect(x + 8, y + 4, 4, 16);
		g.fillRect(x + 12, y + 8, 4, 16);
		g.fillRect(x + 16, y + 4, 4, 16);
		g.fillRect(x + 20, y + 4, 4, 12);
		g.setColor(Color.WHITE);
		g.fillRect(x + 20, y + 4, 4, 4);
		for (int i = 0; i < powerUp.size(); i++) {
			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
		}
	}

	public void drawManaUp(int x, int y, Graphics g) {
		g.setColor(Color.BLUE);
		g.fillRect(x + 4, y + 4, 20, 20);
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 8, 4, 12);
		g.fillRect(x + 4, y + 4, 4, 4);
		g.fillRect(x + 4, y + 20, 4, 4);
		g.fillRect(x + 8, y, 12, 4);
		g.fillRect(x + 8, y + 24, 12, 4);
		g.fillRect(x + 20, y + 4, 4, 4);
		g.fillRect(x + 20, y + 20, 4, 4);
		g.fillRect(x + 24, y + 8, 4, 12);
		g.setColor(Color.WHITE);
		g.fillRect(x + 16, y + 8, 4, 4);
		for (int i = 0; i < powerUp.size(); i++) {
			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.BLUE, g);
		}
	}
	
	public void drawDamageUp(int x, int y, Graphics g) {
		g.setColor(Color.RED);
		g.fillRect(x + 4, y + 4, 20, 20);
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 4, 4, 16);
		g.fillRect(x + 4, y, 20, 4);
		g.fillRect(x + 4, y + 12, 12, 4);
		g.fillRect(x + 4, y + 20, 4, 8);
		g.fillRect(x + 4, y + 24, 20, 4);
		g.fillRect(x + 8, y, 4, 16);
		g.fillRect(x + 16, y, 4, 12);
		g.fillRect(x + 16, y + 8, 12, 4);
		g.fillRect(x + 24, y + 4, 4, 16);
		g.fillRect(x + 16, y + 16, 4, 4);
		g.fillRect(x + 20, y + 20, 4, 4);
		for (int i = 0; i < powerUp.size(); i++) {
			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
		}
	}
	
	public void drawDefenseUp(int x, int y, Graphics g) {
		g.setColor(Color.BLACK);
		g.fillRect(x, y, 4, 16);
		g.fillRect(x, y, 32, 4);
		g.fillRect(x + 4, y + 16, 4, 4);
		g.fillRect(x + 8, y + 20, 4, 4);
		g.fillRect(x + 12, y + 24, 8, 4);
		g.fillRect(x + 20, y + 20, 4, 4);
		g.fillRect(x + 24, y + 16, 4, 4);
		g.fillRect(x + 28, y, 4, 16);
		Color shieldShade = new Color(130, 130, 130);
		g.setColor(shieldShade);
		g.fillRect(x + 4, y + 4, 12, 12);
		g.fillRect(x + 8, y + 16, 8, 4);
		g.fillRect(x + 12, y + 20, 4, 4);
		Color shield = new Color(201, 201, 201);
		g.setColor(shield);
		g.fillRect(x + 16, y + 20, 4, 4);
		g.fillRect(x + 16, y + 16, 8, 4);
		g.fillRect(x + 16, y + 4, 12, 12);
		for (int i = 0; i < powerUp.size(); i++) {
			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, shield, g);
		}
	}
	
	public void drawPowerUpArrow(int x, int y, int counter, Color color, Graphics g) {
		if (counter > 500 && counter < 1000) {
			y += 4;
		}
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 8, 4, 4);
		g.fillRect(x + 4, y + 4, 4, 4);
		g.fillRect(x + 4, y + 12, 4, 12);
		g.fillRect(x + 8, y, 4, 4);
		g.fillRect(x + 8, y + 20, 4, 4);
		g.fillRect(x + 12, y + 4, 4, 4);
		g.fillRect(x + 12, y + 12, 4, 12);
		g.fillRect(x + 16, y + 8, 4, 4);
		g.setColor(color);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 8, y + 4, 4, 16);
	}

	public void movement() {
		if (up == true) {
			if (y > barrierY) {
				barrierY++;
				locationY--;
				movementTrackerY--;

				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, 1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, 1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(1 + powerUp.get(i).getY());
				}
			}
		}

		if (down == true) {
			// y++;
			if (y < barrierY + barrierH - 20) {
				barrierY--;
				locationY++;
				movementTrackerY++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, -1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, -1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(-1 + powerUp.get(i).getY());
				}
			}
		}
		if (left == true) {
			//x--;
			if (x > barrierX) {
				barrierX++;
				locationX--;
				movementTrackerX--;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, 1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesX.set(i, 1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(1 + powerUp.get(i).getX());
				}
			}
		}
		if (right == true) {
			// x++;
			if (x < barrierX + barrierW - 20) {
				barrierX--;
				locationX++;
				movementTrackerX++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, -1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesX.size(); i++) {
					gravesX.set(i, -1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(-1 + powerUp.get(i).getX());
				}
			}
		}

		for (int i = 0; i < playerShot.size(); i++) {
			if (up) {
				bulletY.set(i, 1 + bulletY.get(i));
			}
			if (down) {
				bulletY.set(i, -1 + bulletY.get(i));
			}
			if (left) {
				bulletX.set(i, 1 + bulletX.get(i));
			}
			if (right) {
				bulletX.set(i, -1 + bulletX.get(i));
			}
		}
	}

	public void shootingMechanic() {

		double angle = Math.atan2((x + 15) - mouseX, (y + 35) - mouseY);
		
		if (shooting == true) {
			shootingCounter++;
			if (shootingCounter == 1) {
				playerShot.add(true);
				bulletLife.add(950);
				bulletX.add((double) x);
				bulletY.add((double) y);
				bulletXAngle.add(Math.sin(angle));
				bulletYAngle.add(Math.cos(angle));
				bulletAimAngle.add(angle);
			}
			if (shootingCounter == 50)
				shootingCounter = 0;
		} else {
			shootingCounter = 0;
		}

		for (int i = 0; i < playerShot.size(); i++) {
			bulletLife.set(i, -5 + bulletLife.get(i));
			if (playerShot.get(i)) {
				bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
				bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
			}
			if (bulletLife.get(i) <= 0) {
				bulletCleanup(i);
			}
		}
		if (ability) {
			abilityMechanic();
		} else if (mana < 100) {
			mana += 0.025 + (manaUp * 0.00625);
		}
	}

	public void abilityMechanic() {
		mana = 0;
		for (int i = 0; i < 30; i++) {
			double angle = Math.toRadians(0 + (i * 12));
			bulletXAngle.add(Math.sin(angle));
			bulletYAngle.add(Math.cos(angle));
			bulletAimAngle.add(angle);
			playerShot.add(true);
			bulletLife.add(950);
			bulletX.add((double) mouseX);
			bulletY.add((double) mouseY);
		}
		ability = false;
	}

	public void enemyLogic() {
//
		for (int i = 0; i < enemy.size(); i++) {
			
			enemy.get(i).movement(x, y);
			
			enemy.get(i).aggro(x, y, 20, 20);
			
			for (int i2 = 0; i2 < playerShot.size(); i2++) {
				if (enemyHit(i, i2)) {
					bulletCleanup(i2);
					enemy.get(i).setHP((-10 - (damageUp * 2)) + enemy.get(i).getHP());
				}
			}
//			if (enemyAlive.size() > 0) {
//				enemyMovement(enemyX, enemyY, enemyW, enemyH, i);
//				predictiveAiming(i);
//			}
//
//			if (enemyAlive.size() > 100) {
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
			
			if (enemy.get(i).getHP() <= 0) {
				enemy.remove(i);
				killCount++;
			}
//
//			if (enemyHP.get(i) <= 0)
//				enemyAlive.set(i, false);
//			if (enemyAlive.get(i) == false) {
//					killCount++;
//					int powerUpSpawn = random.nextInt(11); //TODO
//					powerUp(powerUpSpawn, i);
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
		}
	}

//	public void enemyMovement(ArrayList<Double> x, ArrayList<Double> y, ArrayList<Double> w, ArrayList<Double> h,
//			int i) {
//		if (enemyAlive.size() > enemyDirectionCounter.size()) {
//			enemyDirectionCounter.add(0);
//		}
//		enemyDirectionCounter.set(i, 1 + enemyDirectionCounter.get(i));
//		if (enemyDirectionCounter.get(i) == 1) {
//			int direction = random.nextInt(359);
//			double angle = direction;
//			double angle2 = Math.atan2((enemyX.get(i) + 85) - (this.x - 10), (y.get(i) + 70) - this.y);
//			if (movementAngleX.size() < enemyAlive.size()) {
//				movementAngleX.add(Math.sin(angle));
//				movementAngleY.add(Math.cos(angle));
//			} else {
////				if (playerAlive && x.get(i) < 1000 && y.get(i) < 650 && 0 < x.get(i) + w.get(i)
////						&& 0 < y.get(i) + h.get(i)) {
//					movementAngleX.set(i, (Math.sin(angle) + Math.sin(angle2)));
//					movementAngleY.set(i, (Math.cos(angle) + Math.cos(angle2)));
////				} else {
////					movementAngleX.set(i, Math.sin(angle));
////					movementAngleY.set(i, Math.cos(angle));
////				}
//			}
//		}
//		if (enemyDirectionCounter.get(i) < 50) {
//			x.set(i, x.get(i) - movementAngleX.get(i) * 0.125);
//			y.set(i, y.g et(i) - movementAngleY.get(i) * 0.125);
//		} else if (enemyDirectionCounter.get(i) >= 50) {
//			enemyDirectionCounter.set(i, 0);
//		}
//	}

	public boolean enemyHit(int i, int i2) {
		if (enemy.size() > 0) {
			if (bulletX.get(i2) < (enemy.get(i).getX() + 130.0) + 40.0 && enemy.get(i).getX() + 40.0 < bulletX.get(i2) + 10
					&& bulletY.get(i2) < (enemy.get(i).getY() + 130.0) + 10 && enemy.get(i).getY() < bulletY.get(i2) + 10) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	public void bulletCleanup(int i) {
		playerShot.remove(i);
		bulletLife.remove(i);
		bulletX.remove(i);
		bulletY.remove(i);
		bulletXAngle.remove(i);
		bulletYAngle.remove(i);
		bulletAimAngle.remove(i);
	}

//	public void enemyBulletLogic() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double angle = Math.atan2((enemyX.get(i) + 85) - (x - 10), (enemyY.get(i) + 70) - y);
//			enemyShootingCounter.set(i, 1 + enemyShootingCounter.get(i));
//			if (enemyShootingCounter.get(i) == 400 && enemyName.get(i) == "SpyEye"
//					|| enemyShootingCounter.get(i) == 500 && enemyName.get(i) == "MudMuk"
//					|| enemyShootingCounter.get(i) == 450 && enemyName.get(i) == "Hugsbert"
//					|| enemyName.get(i) == "MadMask") {
//				if (enemyName.get(i) == "SpyEye") {
//					omnidirectionalPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					shotgunPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					predictiveAimAngle.set(i, predictiveAim(x, y, enemyX.get(i), enemyY.get(i), angle, i));
//					shotgunPattern(predictiveAimAngle.get(i), i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MadMask") {
//					if (enemyShootingCounter.get(i) == 50 || enemyShootingCounter.get(i) == 100
//							|| enemyShootingCounter.get(i) == 150 || enemyShootingCounter.get(i) == 200
//							|| enemyShootingCounter.get(i) == 250)
//						genericPattern(angle, i);
//					else if (enemyShootingCounter.get(i) == 450)
//						enemyShootingCounter.set(i, 0);
//				}
//			}
//		}
//		for (int i2 = 0; i2 < enemyShooting.size(); i2++) {
//			bulletMovement(i2);
//		}
//	}

//	public void bulletMovement(int i) {
//		enemyBulletLife.set(i, -1 + enemyBulletLife.get(i));
//		enemyBulletX.set(i, enemyBulletX.get(i) - enemyBulletXAngle.get(i) * enemyBulletSpeed.get(i));
//		enemyBulletY.set(i, enemyBulletY.get(i) - enemyBulletYAngle.get(i) * enemyBulletSpeed.get(i));
//
//		if (enemyBulletLife.get(i) <= 0 || enemyShot.get(i) == false) {
//			enemyBulletOrigin.remove(i);
//			enemyBulletX.remove(i);
//			enemyBulletY.remove(i);
//			enemyBulletW.remove(i);
//			enemyBulletH.remove(i);
//			enemyBulletXAngle.remove(i);
//			enemyBulletYAngle.remove(i);
//			enemyBulletAimAngle.remove(i);
//			enemyBulletSpeed.remove(i);
//			enemyShooting.remove(i);
//			enemyShot.remove(i);
//			enemyBulletLife.remove(i);
//		}
//	}

	public double predictiveAim(int x, int y, double ex, double ey, double angle, int i) {
		double calculationX = ((storedX.get(i) - storedX2.get(i)) * -1) * 50;
		double calculationY = ((storedY.get(i) - storedY2.get(i)) * -1) * 50;
		// System.out.println(i + ": "+ storedX.get(i));
		// System.out.println((i+1) + ": "+ storedX.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationX);
		// System.out.println(i + ": "+ storedY.get(i));
		// System.out.println((i+1) + ": "+ storedY.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationY);
		// System.out.println(calculationX + ", " + calculationY);
		angle = Math.atan2((ex + 85) - ((x - 10) + calculationX), (ey + 70) - ((y - 10) + calculationY));
		// System.out.println(Math.toDegrees(angle));
		return angle;
	}

//	public void predictiveAiming(int i) {
//		if (storedX.size() < enemyAlive.size()) {
//			storedX.add(i, (double) movementTrackerX);
//			storedY.add(i, (double) movementTrackerY);
//			storedX2.add(i, (double) movementTrackerX);
//			storedY2.add(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 445) {
//			storedX.set(i, (double) movementTrackerX);
//			storedY.set(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 449) {
//			storedX2.set(i, (double) movementTrackerX);
//			storedY2.set(i, (double) movementTrackerY);
//		}
//	}

//	public void genericPattern(double angle, int i) {
//		if (enemyName.get(i) == "MadMask") {
//			enemyShooting.add(true);
//			enemyShot.add(true);
//			enemyBulletOrigin.add("MadMask");
//			enemyBulletX.add(enemyX.get(i) + 59.5);
//			enemyBulletY.add(enemyY.get(i) + 63.5);
//			enemyBulletW.add(25.0);
//			enemyBulletH.add(25.0);
//			enemyBulletXAngle.add(Math.sin(angle));
//			enemyBulletYAngle.add(Math.cos(angle));
//			enemyBulletAimAngle.add(angle);
//			enemyBulletLife.add(500);
//			enemyBulletSpeed.add(2.0);
//		}
//	}

//	public void shotgunPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "MudMuk") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("MudMuk");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2))));
//				enemyBulletSpeed.add(1.6);
//				enemyBulletLife.add(150);
//			}
//			if (enemyName.get(i) == "Hugsbert") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("Hugsbert");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2))));
//				enemyBulletSpeed.add(1.75);
//				enemyBulletLife.add(250);
//			}
//			// TODO - figure out how to do predictive aim
//		}
//	}

//	public void omnidirectionalPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "SpyEye") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("SpyEye");
//				enemyBulletX.add(enemyX.get(i) + 90);
//				enemyBulletY.add(enemyY.get(i) + 65);
//				enemyBulletW.add(30.0);
//				enemyBulletH.add(30.0);
//				enemyBulletXAngle.add(Math.sin(angle + Math.toRadians(72 * i2)));
//				enemyBulletYAngle.add(Math.cos(angle + Math.toRadians(72 * i2)));
//				enemyBulletAimAngle.add(angle + Math.toRadians(72 * i2));
//				enemyBulletSpeed.add(2.5);
//				enemyBulletLife.add(200);
//			}
//		}
//	}

//	public void bulletCollision() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			for (int i2 = i * 5; i2 >= i * 5 && i2 < (i * 5) + 5 && i2 < enemyShooting.size(); i2++) {
//				if (enemyBulletX.get(i2) < x + 20 && x < enemyBulletX.get(i2) + enemyBulletW.get(i2)
//						&& enemyBulletY.get(i2) < y + 20 && y < enemyBulletY.get(i2) + enemyBulletH.get(i2)) {
//					if (enemyName.get(i) == "SpyEye") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MudMuk") {
//						if ((defenseUp / 4) < 2) {
//							playerHP -= 2 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "Hugsbert") {
//						if ((defenseUp / 4) < 10) {
//							playerHP -= 10 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MadMask") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					}
//					enemyShot.set(i2, false);
//				}
//			}
//		}
//	}

//	public void powerUp(int spawnRate, int i) {
//
//		if (spawnRate == 0 || spawnRate == 1) {
//			powerUp.add(true);
//			powerUpType.add("Health");
//		} else if (spawnRate == 2 || spawnRate == 3) {
//			powerUp.add(true);
//			powerUpType.add("Mana");
//		} else if (spawnRate == 4) {
//			powerUp.add(true);
//			powerUpType.add("Damage");
//		} else if (spawnRate == 5) {
//			powerUp.add(true);
//			powerUpType.add("Defense");
//		}
//		for (int i2 = 0; i2 < powerUp.size(); i2++) {
//			if (powerUp.get(i2) && powerUp.size() > powerUpX.size() && i2 == powerUpX.size()) {
//				int[] enemyX2 = new int[enemyX.size()];
//				int[] enemyY2 = new int[enemyY.size()];
//				enemyX2[i] += enemyX.get(i) + (enemyW.get(i) / 2) - 12;
//				enemyY2[i] += enemyY.get(i) + (enemyH.get(i) / 2) - 12;
//				powerUpX.add(enemyX2[i]);
//				powerUpY.add(enemyY2[i]);
//				// if (powerUp.get(i2) == false) {
//				// powerUpX.remove(i2);
//				// powerUpY.remove(i2);
//				// powerUp.remove(i2);
//				// }
//			}
//		}
//	}

//	public boolean powerUpCollected(int i) {
//		if (x < powerUpX.get(i) + 44 && y < powerUpY.get(i) + 24 && powerUpX.get(i) < x + 24
//				&& powerUpY.get(i) < y + 20) {
//			return true;
//		} else {
//			return false;
//		}
//	}
	
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		
		Graphics2D g2d = (Graphics2D)g;
		
//		drawPowerUpArrow(500, 10, powerUpAnimation, (Color.RED), g);
		
		powerUpAnimation++;
		if (powerUpAnimation == 1000)
			powerUpAnimation = 0;
		for (int i = 0; i < powerUp.size(); i++) {
			powerUp.get(i).draw(g);
//			if (powerUpType.get(i) == "Health")
//				drawHealthUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Mana")
//				drawManaUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Damage")
//				drawDamageUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Defense")
//				drawDefenseUp(powerUpX.get(i), powerUpY.get(i), g);
		}

		drawPreviousDeaths(g);

		g.drawRect(barrierX, barrierY, barrierW, barrierH);

		
		
		drawEnemies(g);
//		
//		for (int i = 0; i < enemyName.size(); i++) {
//			if (enemyName.get(i) == "MadMask") {
//				drawMadMaskBullets(g, g2d);
//			} else if (enemyName.get(i) == "SpyEye") {
//				drawSpyEyeBullets(g, g2d);
//			} else if (enemyName.get(i) == "Hugsbert") {
//				drawHugsbertBullets(g, g2d);
//			} else {
//				drawMudMukBullets(g, g2d);
//			}
//		}

		if (playerAlive) {
			drawPlayer(x, y, g);
		} else {
			drawDeadPlayer(x, y, g);
		}

		g.drawString("Personal Best: " + hiScore, 10, 20);
		g.drawString("Kill Count: " + killCount, 10, 40);

		g.drawString("Enemies Alive: " + enemy.size(), 10, 65);
		g.drawString("Regen: " + regenUp, 10, 85);
		g.drawString("Mana Regen: " + manaUp, 10, 105);
		g.drawString("Damage: " + damageUp, 10, 125);
		g.drawString("Defense: " + defenseUp, 10, 145);
		
		drawBullets(g, g2d);
	}
	
	@Override
	public void actionPerformed(ActionEvent e) {
		
		spawning();
		
//		if (manaUp > 20) manaUp = 20; //mana cap


		
		regen++;
		if (regen > (300 - (regenUp * 5)) && playerHP < 100) {
			playerHP += 2 + regenUp;
			regen = 0;
		}
		if (playerHP > 100) {
			playerHP = 100;
		}
		for (int i = 0; i < powerUp.size(); i++) {
			if (powerUp.get(i).collected(player.getX(), y, w, h)) {
				if (powerUpType.get(i) == "Health")
					regenUp++;
				else if (powerUpType.get(i) == "Mana")
					manaUp++;
				else if (powerUpType.get(i) == "Damage") 
					damageUp++;
				else if (powerUpType.get(i) == "Defense") 
					defenseUp++;
				
				powerUpX.remove(i);
				powerUpY.remove(i);
				powerUp.remove(i);
				powerUpType.remove(i);
			}
		}

		if (playerHP <= 0) {
			playerAlive = false;
		}

		if (playerAlive) {
			movement();
			shootingMechanic();
//			bulletCollision();
		} else {
			for (int i = 0; i < playerShot.size(); i++) {
				bulletLife.set(i, -5 + bulletLife.get(i));
				if (playerShot.get(i)) {
					bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
					bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
				}
				if (bulletLife.get(i) <= 0) {
					bulletCleanup(i);
				}
			}
			try {
				recordDeath(locationX, locationY);
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

		enemyLogic();
//		enemyBulletLogic();
		
		try {
			highScoreWriter(hiScore);
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		

		repaint();
	}

	public void keyPressed(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = true;
		}
		if (key == 'A') {
			left = true;
		}
		if (key == 'S') {
			down = true;
		}
		if (key == 'D') {
			right = true;
		}
		if (key == KeyEvent.VK_SPACE && mana >= 100) {
			ability = true;
		}
	}
	public void keyReleased(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = false;
		}
		if (key == 'A') {
			left = false;
		}
		if (key == 'S') {
			down = false;
		}
		if (key == 'D') {
			right = false;
		}
		if (key == KeyEvent.VK_SPACE && mana == 100) {
			ability = false;
		}
	}

	@Override
	public void mouseClicked(MouseEvent e) {
	}
	@Override
	public void mousePressed(MouseEvent e) {
		shooting = true;
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		shooting = false;
	}
	@Override
	public void mouseDragged(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseMoved(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseEntered(MouseEvent e) {

	}
	@Override
	public void mouseExited(MouseEvent e) {

	}

	private void initComponents() {
		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
		this.setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 400, Short.MAX_VALUE));
		layout.setVerticalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 300, Short.MAX_VALUE));
	}

}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-01-22 16:55:10.656
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-01-22 16:55:10.660
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.e4.ui.workbench 4 2 2021-01-23 00:16:34.497
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:524)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:232)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:240)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:94)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:68)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at sun.reflect.GeneratedMethodAccessor43.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:993)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:966)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:261)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2110)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1741)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.Workbench$10.run(Workbench.java:1125)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1108)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1409)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1409)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1385)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1737)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1775)
	at org.eclipse.ui.internal.WorkbenchWindow$3.close(WorkbenchWindow.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:577)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:284)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1573)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4763)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3583)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2021-01-23 00:16:35.959
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:524)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:232)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:240)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:94)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:68)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at sun.reflect.GeneratedMethodAccessor43.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:993)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:966)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:261)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2110)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1741)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.Workbench$10.run(Workbench.java:1125)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1108)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1409)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1409)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1385)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1737)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1775)
	at org.eclipse.ui.internal.WorkbenchWindow$3.close(WorkbenchWindow.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:577)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:284)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1573)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4763)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3583)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SESSION 2021-01-23 20:49:14.812 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-23 20:50:19.435
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-24 13:53:57.647 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-24 13:56:16.727
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 4 2 2021-01-24 16:01:33.968
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:524)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:232)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:240)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:94)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:68)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at sun.reflect.GeneratedMethodAccessor45.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:993)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:966)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:261)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2110)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1741)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.Workbench$10.run(Workbench.java:1125)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1108)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1409)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1409)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1385)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1737)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1775)
	at org.eclipse.ui.internal.WorkbenchWindow$3.close(WorkbenchWindow.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:577)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:284)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1573)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4763)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3583)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2021-01-24 16:01:34.274
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:524)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:232)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:240)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:94)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:68)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at sun.reflect.GeneratedMethodAccessor45.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:993)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:966)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:261)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2110)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1741)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.Workbench$10.run(Workbench.java:1125)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1108)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1409)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1409)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1385)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1737)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1775)
	at org.eclipse.ui.internal.WorkbenchWindow$3.close(WorkbenchWindow.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:577)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:284)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1573)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4763)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3583)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SESSION 2021-01-26 12:22:47.589 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-26 12:23:26.329
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-26 13:24:58.760 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-26 13:25:20.066
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-28 10:05:25.349 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-28 10:06:09.532
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-28 18:13:11.048 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-01-28 18:13:20.221
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2021-01-28 18:13:50.100
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-29 12:08:51.572 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-29 12:09:47.028
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-30 01:35:33.087 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-30 01:36:10.833
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-31 01:04:10.113 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-01-31 01:05:26.600
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-02 13:39:35.092 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-02 13:40:31.927
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.e4.ui.workbench 4 2 2021-02-02 14:57:43.112
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.e4.ui.workbench".
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:524)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:232)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:240)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:94)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:68)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at sun.reflect.GeneratedMethodAccessor45.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:993)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:966)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:261)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2110)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1741)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.Workbench$10.run(Workbench.java:1125)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1108)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1409)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1409)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1385)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1737)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1775)
	at org.eclipse.ui.internal.WorkbenchWindow$3.close(WorkbenchWindow.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:577)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:284)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1573)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4763)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3580)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)

!ENTRY org.eclipse.e4.ui.workbench 4 0 2021-02-02 14:57:43.595
!MESSAGE 
!STACK 0
java.lang.NullPointerException
	at org.eclipse.ui.internal.handlers.LegacyHandlerService.getCurrentState(LegacyHandlerService.java:572)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getEvaluationContext(SelectionUtils.java:524)
	at org.eclipse.egit.ui.internal.selection.SelectionUtils.getStructuredSelection(SelectionUtils.java:232)
	at org.eclipse.egit.ui.internal.selection.RepositorySourceProvider.selectionChanged(RepositorySourceProvider.java:90)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.notifyListeners(SelectionService.java:240)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.handleSelectionChanged(SelectionService.java:94)
	at org.eclipse.ui.internal.e4.compatibility.SelectionService.lambda$0(SelectionService.java:68)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$1.run(SelectionAggregator.java:123)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.notifyListeners(SelectionAggregator.java:120)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.access$2(SelectionAggregator.java:118)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.lambda$0(SelectionAggregator.java:220)
	at org.eclipse.e4.core.contexts.RunAndTrack.runExternalCode(RunAndTrack.java:59)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator$5.changed(SelectionAggregator.java:220)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:108)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.runAndTrack(EclipseContext.java:346)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.track(SelectionAggregator.java:205)
	at org.eclipse.e4.ui.internal.workbench.SelectionAggregator.setPart(SelectionAggregator.java:114)
	at sun.reflect.GeneratedMethodAccessor45.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.contexts.ContextObjectSupplier$ContextInjectionListener.update(ContextObjectSupplier.java:95)
	at org.eclipse.e4.core.internal.contexts.TrackableComputationExt.update(TrackableComputationExt.java:105)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.processScheduled(EclipseContext.java:364)
	at org.eclipse.e4.core.internal.contexts.EclipseContext.dispose(EclipseContext.java:188)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.clearContext(PartRenderingEngine.java:993)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:966)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.disposeWidget(ContributedPartRenderer.java:261)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.disposeWidget(ElementReferenceRenderer.java:115)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:945)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:900)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeRemoveGui(PartRenderingEngine.java:907)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.access$1(PartRenderingEngine.java:873)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$4.run(PartRenderingEngine.java:868)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.removeGui(PartRenderingEngine.java:852)
	at org.eclipse.ui.internal.WorkbenchWindow.hardClose(WorkbenchWindow.java:2110)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1741)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.Workbench$10.run(Workbench.java:1125)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.internal.Workbench.busyClose(Workbench.java:1108)
	at org.eclipse.ui.internal.Workbench.lambda$4(Workbench.java:1409)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1409)
	at org.eclipse.ui.internal.Workbench.close(Workbench.java:1385)
	at org.eclipse.ui.internal.WorkbenchWindow.busyClose(WorkbenchWindow.java:1737)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$3(WorkbenchWindow.java:1766)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1766)
	at org.eclipse.ui.internal.WorkbenchWindow.close(WorkbenchWindow.java:1775)
	at org.eclipse.ui.internal.WorkbenchWindow$3.close(WorkbenchWindow.java:527)
	at org.eclipse.e4.ui.workbench.renderers.swt.WBWRenderer.lambda$4(WBWRenderer.java:577)
	at org.eclipse.swt.events.ShellListener$2.shellClosed(ShellListener.java:102)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:102)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4173)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1057)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1081)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Decorations.closeWidget(Decorations.java:284)
	at org.eclipse.swt.widgets.Decorations.WM_CLOSE(Decorations.java:1573)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4763)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.DefWindowProc(Native Method)
	at org.eclipse.swt.widgets.Shell.callWindowProc(Shell.java:508)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4858)
	at org.eclipse.swt.widgets.Canvas.windowProc(Canvas.java:348)
	at org.eclipse.swt.widgets.Decorations.windowProc(Decorations.java:1501)
	at org.eclipse.swt.widgets.Shell.windowProc(Shell.java:2138)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4812)
	at org.eclipse.swt.internal.win32.OS.PeekMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3580)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SESSION 2021-02-02 18:50:04.820 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-02 18:50:46.244
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-02-02 19:23:25.449
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package oryx;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

import javax.swing.Timer;

import enemies.Enemies;
import enemies.Hugsbert;
import enemies.MadMask;
import enemies.MudMuk;
import enemies.SpyEye;

import javax.imageio.ImageIO;
import javax.swing.JPanel;

public class Display extends JPanel implements ActionListener, MouseListener, MouseMotionListener {

	// String path = System.getProperty("home.dir");

	/*
	 * SpyEye - fires in all directions MudMuk - fires straight at the player in a
	 * shotgun pattern Hugsbert - predicts where the player will be MadMask -
	 * periodically rapid fires at the player
	 */

	Oryx oryx = new Oryx();
	Player player = new Player((oryx.frame.getWidth() / 2) - 10, (oryx.frame.getHeight() / 2) - 10, 20, 20);
	ArrayList<Enemies> enemy = new ArrayList<Enemies>();
	
	ArrayList<Bullet> bullet = new ArrayList
	
	ArrayList<PowerUp> powerUp = new ArrayList<PowerUp>();

//	int x = (oryx.frame.getWidth() / 2) - 10, y = (oryx.frame.getHeight() / 2) - 10;
//	int locationX = x, locationY = y;
	int movementTrackerX = 0, movementTrackerY = 0;

	boolean playerAlive = true;
//	int playerHP = 100;
	boolean up = false, down = false, left = false, right = false;
	boolean shooting = false;

	boolean ability = false;
//	double mana = 100;

	int regen = 0;
	int regenUp = 0;
	int manaUp = 0;
	int damageUp = 0;
	int defenseUp = 0;
	int powerUpAnimation = 0;

	int shootingCounter = 0;

	int hiScore, killCount = 0;

	int mouseX = 0, mouseY = 0;

	int barrierX = -2000, barrierY = -2000, barrierW = 5000, barrierH = 5000;

	int spawnRate;

	String[] enemyNames = { "SpyEye", "MudMuk", "Hugsbert", "MadMask" };
	
	Random random = new Random();

	ArrayList<Boolean> playerShot = new ArrayList<Boolean>();
	ArrayList<Integer> bulletLife = new ArrayList<Integer>();
	ArrayList<Double> bulletX = new ArrayList<Double>();
	ArrayList<Double> bulletY = new ArrayList<Double>();
	ArrayList<Double> bulletXAngle = new ArrayList<Double>();
	ArrayList<Double> bulletYAngle = new ArrayList<Double>();
	ArrayList<Double> bulletAimAngle = new ArrayList<Double>();

//	ArrayList<String> powerUpType = new ArrayList<String>();
//	ArrayList<Integer> powerUpX = new ArrayList<Integer>();
//	ArrayList<Integer> powerUpY = new ArrayList<Integer>();

	ArrayList<Integer> gravesX = new ArrayList<Integer>();
	ArrayList<Integer> gravesY = new ArrayList<Integer>();

	
//	ArrayList<String> enemyName = new ArrayList<String>();
//	ArrayList<Boolean> enemyAlive = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShot = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShooting = new ArrayList<Boolean>();
//	ArrayList<Double> enemyX = new ArrayList<Double>();
//	ArrayList<Double> enemyY = new ArrayList<Double>();
//	ArrayList<Double> enemyW = new ArrayList<Double>();
//	ArrayList<Double> enemyH = new ArrayList<Double>();
//	ArrayList<String> enemyBulletOrigin = new ArrayList<String>();
//	ArrayList<Double> enemyBulletX = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletY = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletW = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletH = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletXAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletYAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletAimAngle = new ArrayList<Double>();
//	ArrayList<Integer> enemyBulletLife = new ArrayList<Integer>();
//	ArrayList<Double> enemyBulletSpeed = new ArrayList<Double>();
//	ArrayList<Integer> enemyShootingCounter = new ArrayList<Integer>();
//	ArrayList<Integer> enemyHP = new ArrayList<Integer>();
//	ArrayList<Integer> enemyDirectionCounter = new ArrayList<Integer>();
//	ArrayList<Double> movementAngleX = new ArrayList<Double>();
//	ArrayList<Double> movementAngleY = new ArrayList<Double>();

	ArrayList<Double> storedX = new ArrayList<Double>();
	ArrayList<Double> storedY = new ArrayList<Double>();
	ArrayList<Double> storedX2 = new ArrayList<Double>();
	ArrayList<Double> storedY2 = new ArrayList<Double>();
	ArrayList<Double> predictiveAimAngle = new ArrayList<Double>();

	Timer t;

	AffineTransform at = new AffineTransform();
	
	BufferedImage playerBullet = null;
	BufferedImage madMaskBullet = null;
	BufferedImage SpyEyeBullet = null;
	BufferedImage HugsbertBullet = null;
	BufferedImage MudMukBullet = null;
	
	// Image player = Toolkit.getDefaultToolkit().getImage(path +
	// "/src/images/BulletHellShip.png");

	public Display() throws IOException {
		initComponents();
		t = new Timer(1, this);
		t.start();

		previousDeaths();
		
		bufferImages();
	}

	public void	bufferImages() {
		try {
		    playerBullet = ImageIO.read(new File("src/images/OryxBullet1.png"));
		} catch (IOException e) { 
		}
		try {
		    madMaskBullet = ImageIO.read(new File("src/images/MadMaskBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    SpyEyeBullet = ImageIO.read(new File("src/images/SpyEyeBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    HugsbertBullet = ImageIO.read(new File("src/images/HugsbertBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    MudMukBullet = ImageIO.read(new File("src/images/MudMukBullet.png"));
		} catch (IOException e) { 
		}
	}
	
	public void highScoreWriter(int highScore) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/hiScore.txt");
		Scanner s = new Scanner(file);
		String line;
		line = s.nextLine();
		highScore = Integer.parseInt(line);
		if (killCount > highScore) {
			highScore = killCount;
			FileWriter output = new FileWriter(file);
			output.write(new Integer(highScore).toString());
			output.close();
		}
		this.hiScore = highScore;
	}

	public void previousDeaths() throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		Scanner s = new Scanner(file);
		if (s.hasNextLine()) {
			String line = s.nextLine();
			String[] coordinates = line.split(" ");
			for (int i = 0; i < coordinates.length; i++) {
				String[] chopped = coordinates[i].split(",");
				gravesX.add(Integer.parseInt(chopped[0]));
				gravesY.add(Integer.parseInt(chopped[1]));
			}
		}

		// while (s.hasNext()) {
		// line = s.nextLine();
		// chopped = line.split(", ");
		// gravesX.add(Integer.parseInt(chopped[0]));
		// gravesY.add(Integer.parseInt(chopped[1]));
		// }
		s.close();
	}

	public void recordDeath(int x, int y) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		FileWriter output = new FileWriter(file);
		for (int i = 0; i < gravesX.size(); i++) {
			output.write(new Integer(gravesX.get(i) + movementTrackerX).toString());
			output.write(",");
			output.write(new Integer(gravesY.get(i) + movementTrackerY).toString());
			output.write(" ");
		}
		output.write(new Integer(x).toString());
		output.write(",");
		output.write(new Integer(y).toString());
		output.write(" ");
		output.close();
	}

	public void drawPreviousDeaths(Graphics g) {
		int[] gravesX2 = new int[gravesX.size()];
		int[] gravesY2 = new int[gravesY.size()];
		for (int i = 0; i < gravesX.size(); i++) {
			gravesX2[i] = gravesX.get(i);
			gravesY2[i] = gravesY.get(i);
			drawDeadPlayer(gravesX2[i], gravesY2[i], g);
		}
	}
	
	public void spawning() {
		
		spawnRate = random.nextInt(500) + 1;

		if (spawnRate == 500) {
			double spawnPointX = random.nextInt((barrierX + barrierW) - 100) + barrierX + 100;
			double spawnPointY = random.nextInt((barrierY + barrierH) - 100) + barrierY + 100;

			String name = enemyNames[random.nextInt(4)];
			
//			0 - SpyEye
//			1 - MudMuk
//			2 - Hugsbert
//			3 - MadMask
			
			switch (name) {
				case "SpyEye" : {
					enemy.add(new SpyEye(spawnPointX, spawnPointY));
					break;
				}
				case "MudMuk" : {
					enemy.add(new MudMuk(spawnPointX, spawnPointY));
					break;
				}
				case "Hugsbert" : {
					enemy.add(new Hugsbert(spawnPointX, spawnPointY));
					break;
				}
				case "MadMask" : {
					enemy.add(new MadMask(spawnPointX, spawnPointY));
					break;
				}
			}
			
//			enemyAlive.add(true);
//			enemyName.add(enemyNames[random.nextInt(4)]);
//			enemyX.add(spawnPointX);
//			enemyY.add(spawnPointY);
//			predictiveAimAngle.add(0.0);
//			enemyShootingCounter.add(0);
//			for (int i = 0; i < enemyAlive.size(); i++) {
//				if (enemyName.get(i) == "SpyEye") {
//					enemyW.add(210.0);
//					enemyH.add(140.0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					enemyW.add(180.0);
//					enemyH.add(160.0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					enemyW.add(156.0);
//					enemyH.add(168.0);
//				} else if (enemyName.get(i) == "MadMask") {
//					enemyW.add(144.0);
//					enemyH.add(160.0);
//				}
//				if (enemyAlive.size() > enemyHP.size() && i == enemyHP.size()) {
//					if (enemyName.get(i) == "SpyEye") {
//						enemyHP.add(500);
//					} else if (enemyName.get(i) == "MudMuk") {
//						enemyHP.add(700);
//					} else if (enemyName.get(i) == "Hugsbert") {
//						enemyHP.add(600);
//					} else if (enemyName.get(i) == "MadMask") {
//						enemyHP.add(500);
//					}
//				}
//			}
		}
	}

	public void drawDeadPlayer(int x, int y, Graphics g) {
		int[] graveX = { x + 4, x + 4, x + 20, x + 20, x + 24, x + 24, x, x };
		int[] graveY = { y + 4, y, y, y + 4, y + 4, y + 28, y + 28, y + 4 };
		Color graveGray = new Color(200, 200, 200);
		g.setColor(graveGray);
		g.fillRect(x, y + 4, 4, 24);
		g.fillRect(x + 4, y, 4, 28);
		g.fillRect(x + 8, y, 4, 28);
		g.fillRect(x + 12, y, 4, 28);
		g.fillRect(x + 16, y, 4, 28);
		Color graveShade = new Color(152, 152, 152);
		g.setColor(graveShade);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 4, y + 16, 12, 4);
		g.fillRect(x + 16, y, 4, 4);
		g.fillRect(x + 20, y + 4, 4, 24);
		g.setColor(Color.BLACK);
		g.drawPolygon(graveX, graveY, 8);
	}

	public void drawBullets(Graphics g, Graphics2D g2d) {
		for (int i = 0; i < playerShot.size(); i++) {
			double[] bulletX2 = new double[bulletX.size()];
			double[] bulletY2 = new double[bulletY.size()];
			bulletX2[i] = bulletX.get(i);
			bulletY2[i] = bulletY.get(i);
			
			at.rotate(-bulletAimAngle.get(i), bulletX2[i] + ((playerBullet.getWidth()*4)/2), bulletY2[i] + ((playerBullet.getHeight()*4) /2));
			g2d.transform(at);
			g2d.drawImage(playerBullet, (int) bulletX2[i] + 5, (int) bulletY2[i] + 5, 12, 20, null);
			
			try{
		        g2d.transform(at.createInverse());
		    }catch(NoninvertibleTransformException e){
		        //...
		    }
			
			at.setToIdentity();
		}
	}

	public void drawEnemies(Graphics g) {
		
		for (int i = 0; i < enemy.size(); i++) {
			enemy.get(i).draw(g);
		}
//		g.setColor(Color.RED);
//
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double[] enemyX2 = new double[enemyX.size()];
//			double[] enemyY2 = new double[enemyY.size()];
//			enemyX2[i] = enemyX.get(i);
//			enemyY2[i] = enemyY.get(i);
//			if (enemyName.get(i) == "SpyEye") {
//	//			enemy.drawSpyEye((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//			} else if (enemyName.get(i) == "MudMuk") {
//	//			enemy.drawMudMuk((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//			} else if (enemyName.get(i) == "Hugsbert") {
//	//			enemy.drawHugsbert((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//			} else if (enemyName.get(i) == "MadMask") {
//	//			enemy.drawMadMask((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//			}
//			// g.fillRect((int) enemyX2[i], (int) enemyY2[i], 50, 50);
//		}
	}
	
//	public void drawMadMaskBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MadMask") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((madMaskBullet.getWidth()*4)/2), enemyBulletY2[i] + ((madMaskBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(madMaskBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    } catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				} 
//				
//				}
//			}
//	}
//
//	public void drawSpyEyeBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "SpyEye") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((SpyEyeBullet.getWidth()*4)/2), enemyBulletY2[i] + ((SpyEyeBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(SpyEyeBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawHugsbertBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "Hugsbert") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((HugsbertBullet.getWidth()*4)/2), enemyBulletY2[i] + ((HugsbertBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(HugsbertBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawMudMukBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MudMuk") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i), enemyBulletX2[i] + ((MudMukBullet.getWidth()*4)/2), enemyBulletY2[i] + ((MudMukBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(MudMukBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
	
//	public void drawHealthUp(int x, int y, Graphics g) {
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y + 4, 4, 12);
//		g.fillRect(x + 4, y, 8, 4);
//		g.fillRect(x + 4, y + 16, 4, 4);
//		g.fillRect(x + 8, y + 20, 4, 4);
//		g.fillRect(x + 12, y + 4, 4, 4);
//		g.fillRect(x + 12, y + 24, 4, 4);
//		g.fillRect(x + 16, y, 8, 4);
//		g.fillRect(x + 16, y + 20, 4, 4);
//		g.fillRect(x + 20, y + 16, 4, 4);
//		g.fillRect(x + 24, y + 4, 4, 12);
//		g.setColor(Color.RED);
//		g.fillRect(x + 4, y + 4, 4, 12);
//		g.fillRect(x + 8, y + 4, 4, 16);
//		g.fillRect(x + 12, y + 8, 4, 16);
//		g.fillRect(x + 16, y + 4, 4, 16);
//		g.fillRect(x + 20, y + 4, 4, 12);
//		g.setColor(Color.WHITE);
//		g.fillRect(x + 20, y + 4, 4, 4);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
//		}
//	}
//
//	public void drawManaUp(int x, int y, Graphics g) {
//		g.setColor(Color.BLUE);
//		g.fillRect(x + 4, y + 4, 20, 20);
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y + 8, 4, 12);
//		g.fillRect(x + 4, y + 4, 4, 4);
//		g.fillRect(x + 4, y + 20, 4, 4);
//		g.fillRect(x + 8, y, 12, 4);
//		g.fillRect(x + 8, y + 24, 12, 4);
//		g.fillRect(x + 20, y + 4, 4, 4);
//		g.fillRect(x + 20, y + 20, 4, 4);
//		g.fillRect(x + 24, y + 8, 4, 12);
//		g.setColor(Color.WHITE);
//		g.fillRect(x + 16, y + 8, 4, 4);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.BLUE, g);
//		}
//	}
//	
//	public void drawDamageUp(int x, int y, Graphics g) {
//		g.setColor(Color.RED);
//		g.fillRect(x + 4, y + 4, 20, 20);
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y + 4, 4, 16);
//		g.fillRect(x + 4, y, 20, 4);
//		g.fillRect(x + 4, y + 12, 12, 4);
//		g.fillRect(x + 4, y + 20, 4, 8);
//		g.fillRect(x + 4, y + 24, 20, 4);
//		g.fillRect(x + 8, y, 4, 16);
//		g.fillRect(x + 16, y, 4, 12);
//		g.fillRect(x + 16, y + 8, 12, 4);
//		g.fillRect(x + 24, y + 4, 4, 16);
//		g.fillRect(x + 16, y + 16, 4, 4);
//		g.fillRect(x + 20, y + 20, 4, 4);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
//		}
//	}
//	
//	public void drawDefenseUp(int x, int y, Graphics g) {
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y, 4, 16);
//		g.fillRect(x, y, 32, 4);
//		g.fillRect(x + 4, y + 16, 4, 4);
//		g.fillRect(x + 8, y + 20, 4, 4);
//		g.fillRect(x + 12, y + 24, 8, 4);
//		g.fillRect(x + 20, y + 20, 4, 4);
//		g.fillRect(x + 24, y + 16, 4, 4);
//		g.fillRect(x + 28, y, 4, 16);
//		Color shieldShade = new Color(130, 130, 130);
//		g.setColor(shieldShade);
//		g.fillRect(x + 4, y + 4, 12, 12);
//		g.fillRect(x + 8, y + 16, 8, 4);
//		g.fillRect(x + 12, y + 20, 4, 4);
//		Color shield = new Color(201, 201, 201);
//		g.setColor(shield);
//		g.fillRect(x + 16, y + 20, 4, 4);
//		g.fillRect(x + 16, y + 16, 8, 4);
//		g.fillRect(x + 16, y + 4, 12, 12);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, shield, g);
//		}
//	}
	
	public void drawPowerUpArrow(int x, int y, int counter, Color color, Graphics g) {
		if (counter > 500 && counter < 1000) {
			y += 4;
		}
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 8, 4, 4);
		g.fillRect(x + 4, y + 4, 4, 4);
		g.fillRect(x + 4, y + 12, 4, 12);
		g.fillRect(x + 8, y, 4, 4);
		g.fillRect(x + 8, y + 20, 4, 4);
		g.fillRect(x + 12, y + 4, 4, 4);
		g.fillRect(x + 12, y + 12, 4, 12);
		g.fillRect(x + 16, y + 8, 4, 4);
		g.setColor(color);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 8, y + 4, 4, 16);
	}

	public void movement() {
		if (up == true) {
			if (player.getY() > barrierY) {
				barrierY++;
				player.setRealLocationY(-1 + player.getRealLocationY());
				movementTrackerY--;

				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, 1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, 1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(1 + powerUp.get(i).getY());
				}
			}
		}

		if (down == true) {
			// y++;
			if (player.getY() < barrierY + barrierH - 20) {
				barrierY--;
				//locationY++;
				player.setRealLocationY(1 + player.getRealLocationY());
				movementTrackerY++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, -1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, -1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(-1 + powerUp.get(i).getY());
				}
			}
		}
		if (left == true) {
			//x--;
			if (player.getX() > barrierX) {
				barrierX++;
				player.setRealLocationX(-1 + player.getRealLocationX());
				movementTrackerX--;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, 1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesX.set(i, 1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(1 + powerUp.get(i).getX());
				}
			}
		}
		if (right == true) {
			// x++;
			if (player.getX() < barrierX + barrierW - 20) {
				barrierX--;
				player.setRealLocationX(1 + player.getRealLocationX());
				movementTrackerX++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, -1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesX.size(); i++) {
					gravesX.set(i, -1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(-1 + powerUp.get(i).getX());
				}
			}
		}

		for (int i = 0; i < playerShot.size(); i++) {
			if (up) {
				bulletY.set(i, 1 + bulletY.get(i));
			}
			if (down) {
				bulletY.set(i, -1 + bulletY.get(i));
			}
			if (left) {
				bulletX.set(i, 1 + bulletX.get(i));
			}
			if (right) {
				bulletX.set(i, -1 + bulletX.get(i));
			}
		}
	}

	public void shootingMechanic() {

		double angle = Math.atan2((player.getX() + 15) - mouseX, (player.getY() + 35) - mouseY);
		
		if (shooting == true) {
			shootingCounter++;
			if (shootingCounter == 1) {
				playerShot.add(true);
				bulletLife.add(950);
				bulletX.add((double) player.getX());
				bulletY.add((double) player.getY());
				bulletXAngle.add(Math.sin(angle));
				bulletYAngle.add(Math.cos(angle));
				bulletAimAngle.add(angle);
			}
			if (shootingCounter == 50)
				shootingCounter = 0;
		} else {
			shootingCounter = 0;
		}

		for (int i = 0; i < playerShot.size(); i++) {
			bulletLife.set(i, -5 + bulletLife.get(i));
			if (playerShot.get(i)) {
				bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
				bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
			}
			if (bulletLife.get(i) <= 0) {
				bulletCleanup(i);
			}
		}
		if (ability) {
			abilityMechanic();
		} else if (player.getMana() < 100) {
			player.setMana(player.getMana() + 0.025 + (manaUp * 0.00625));
		}
	}

	public void abilityMechanic() {
		player.setMana(0);;
		for (int i = 0; i < 30; i++) {
			double angle = Math.toRadians(0 + (i * 12));
			bulletXAngle.add(Math.sin(angle));
			bulletYAngle.add(Math.cos(angle));
			bulletAimAngle.add(angle);
			playerShot.add(true);
			bulletLife.add(950);
			bulletX.add((double) mouseX);
			bulletY.add((double) mouseY);
		}
		ability = false;
	}

	public void enemyLogic() {
//
		for (int i = 0; i < enemy.size(); i++) {
			
			enemy.get(i).movement(player.getX(), player.getY());
			
			enemy.get(i).aggro(player.getX(), player.getY(), 20, 20);
			
			for (int i2 = 0; i2 < playerShot.size(); i2++) {
				if (enemyHit(i, i2)) {
					bulletCleanup(i2);
					enemy.get(i).setHP((-(player.getAttack() * 2)) + enemy.get(i).getHP());
				}
			}
//			if (enemyAlive.size() > 0) {
//				enemyMovement(enemyX, enemyY, enemyW, enemyH, i);
//				predictiveAiming(i);
//			}
//
//			if (enemyAlive.size() > 100) {
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
			
			if (enemy.get(i).getHP() <= 0) {
				int rando = random.nextInt(23)+1;
				// should be a 25% chance to get a power up 
				switch (rando) {
					case 1 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Vitality"));
						break;
					}
					case 2 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Vitality"));
						break;
					}
					case 3 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Attack"));
						break;
					}
					case 4 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Attack"));
						break;
					}
					case 5 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Defense"));
						break;
					}
					case 6 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Wisdom"));
						break;
					}
					default : {
						System.out.println("Nope, " + rando);
					}
				}
				enemy.remove(i);
				killCount++;
				System.out.println("Rando: " + rando);
			}
//
//			if (enemyHP.get(i) <= 0)
//				enemyAlive.set(i, false);
//			if (enemyAlive.get(i) == false) {
//					killCount++;
//					int powerUpSpawn = random.nextInt(11); //TODO
//					powerUp(powerUpSpawn, i);
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
		}
	}

//	public void enemyMovement(ArrayList<Double> x, ArrayList<Double> y, ArrayList<Double> w, ArrayList<Double> h,
//			int i) {
//		if (enemyAlive.size() > enemyDirectionCounter.size()) {
//			enemyDirectionCounter.add(0);
//		}
//		enemyDirectionCounter.set(i, 1 + enemyDirectionCounter.get(i));
//		if (enemyDirectionCounter.get(i) == 1) {
//			int direction = random.nextInt(359);
//			double angle = direction;
//			double angle2 = Math.atan2((enemyX.get(i) + 85) - (this.x - 10), (y.get(i) + 70) - this.y);
//			if (movementAngleX.size() < enemyAlive.size()) {
//				movementAngleX.add(Math.sin(angle));
//				movementAngleY.add(Math.cos(angle));
//			} else {
////				if (playerAlive && x.get(i) < 1000 && y.get(i) < 650 && 0 < x.get(i) + w.get(i)
////						&& 0 < y.get(i) + h.get(i)) {
//					movementAngleX.set(i, (Math.sin(angle) + Math.sin(angle2)));
//					movementAngleY.set(i, (Math.cos(angle) + Math.cos(angle2)));
////				} else {
////					movementAngleX.set(i, Math.sin(angle));
////					movementAngleY.set(i, Math.cos(angle));
////				}
//			}
//		}
//		if (enemyDirectionCounter.get(i) < 50) {
//			x.set(i, x.get(i) - movementAngleX.get(i) * 0.125);
//			y.set(i, y.g et(i) - movementAngleY.get(i) * 0.125);
//		} else if (enemyDirectionCounter.get(i) >= 50) {
//			enemyDirectionCounter.set(i, 0);
//		}
//	}

	public boolean enemyHit(int i, int i2) {
		if (enemy.size() > 0) {
			if (bulletX.get(i2) < (enemy.get(i).getX() + 130.0) + 40.0 && enemy.get(i).getX() + 40.0 < bulletX.get(i2) + 10
					&& bulletY.get(i2) < (enemy.get(i).getY() + 130.0) + 10 && enemy.get(i).getY() < bulletY.get(i2) + 10) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	public void bulletCleanup(int i) {
		playerShot.remove(i);
		bulletLife.remove(i);
		bulletX.remove(i);
		bulletY.remove(i);
		bulletXAngle.remove(i);
		bulletYAngle.remove(i);
		bulletAimAngle.remove(i);
	}

//	public void enemyBulletLogic() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double angle = Math.atan2((enemyX.get(i) + 85) - (x - 10), (enemyY.get(i) + 70) - y);
//			enemyShootingCounter.set(i, 1 + enemyShootingCounter.get(i));
//			if (enemyShootingCounter.get(i) == 400 && enemyName.get(i) == "SpyEye"
//					|| enemyShootingCounter.get(i) == 500 && enemyName.get(i) == "MudMuk"
//					|| enemyShootingCounter.get(i) == 450 && enemyName.get(i) == "Hugsbert"
//					|| enemyName.get(i) == "MadMask") {
//				if (enemyName.get(i) == "SpyEye") {
//					omnidirectionalPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					shotgunPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					predictiveAimAngle.set(i, predictiveAim(x, y, enemyX.get(i), enemyY.get(i), angle, i));
//					shotgunPattern(predictiveAimAngle.get(i), i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MadMask") {
//					if (enemyShootingCounter.get(i) == 50 || enemyShootingCounter.get(i) == 100
//							|| enemyShootingCounter.get(i) == 150 || enemyShootingCounter.get(i) == 200
//							|| enemyShootingCounter.get(i) == 250)
//						genericPattern(angle, i);
//					else if (enemyShootingCounter.get(i) == 450)
//						enemyShootingCounter.set(i, 0);
//				}
//			}
//		}
//		for (int i2 = 0; i2 < enemyShooting.size(); i2++) {
//			bulletMovement(i2);
//		}
//	}

//	public void bulletMovement(int i) {
//		enemyBulletLife.set(i, -1 + enemyBulletLife.get(i));
//		enemyBulletX.set(i, enemyBulletX.get(i) - enemyBulletXAngle.get(i) * enemyBulletSpeed.get(i));
//		enemyBulletY.set(i, enemyBulletY.get(i) - enemyBulletYAngle.get(i) * enemyBulletSpeed.get(i));
//
//		if (enemyBulletLife.get(i) <= 0 || enemyShot.get(i) == false) {
//			enemyBulletOrigin.remove(i);
//			enemyBulletX.remove(i);
//			enemyBulletY.remove(i);
//			enemyBulletW.remove(i);
//			enemyBulletH.remove(i);
//			enemyBulletXAngle.remove(i);
//			enemyBulletYAngle.remove(i);
//			enemyBulletAimAngle.remove(i);
//			enemyBulletSpeed.remove(i);
//			enemyShooting.remove(i);
//			enemyShot.remove(i);
//			enemyBulletLife.remove(i);
//		}
//	}

	public double predictiveAim(int x, int y, double ex, double ey, double angle, int i) {
		double calculationX = ((storedX.get(i) - storedX2.get(i)) * -1) * 50;
		double calculationY = ((storedY.get(i) - storedY2.get(i)) * -1) * 50;
		// System.out.println(i + ": "+ storedX.get(i));
		// System.out.println((i+1) + ": "+ storedX.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationX);
		// System.out.println(i + ": "+ storedY.get(i));
		// System.out.println((i+1) + ": "+ storedY.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationY);
		// System.out.println(calculationX + ", " + calculationY);
		angle = Math.atan2((ex + 85) - ((x - 10) + calculationX), (ey + 70) - ((y - 10) + calculationY));
		// System.out.println(Math.toDegrees(angle));
		return angle;
	}

//	public void predictiveAiming(int i) {
//		if (storedX.size() < enemyAlive.size()) {
//			storedX.add(i, (double) movementTrackerX);
//			storedY.add(i, (double) movementTrackerY);
//			storedX2.add(i, (double) movementTrackerX);
//			storedY2.add(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 445) {
//			storedX.set(i, (double) movementTrackerX);
//			storedY.set(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 449) {
//			storedX2.set(i, (double) movementTrackerX);
//			storedY2.set(i, (double) movementTrackerY);
//		}
//	}

//	public void genericPattern(double angle, int i) {
//		if (enemyName.get(i) == "MadMask") {
//			enemyShooting.add(true);
//			enemyShot.add(true);
//			enemyBulletOrigin.add("MadMask");
//			enemyBulletX.add(enemyX.get(i) + 59.5);
//			enemyBulletY.add(enemyY.get(i) + 63.5);
//			enemyBulletW.add(25.0);
//			enemyBulletH.add(25.0);
//			enemyBulletXAngle.add(Math.sin(angle));
//			enemyBulletYAngle.add(Math.cos(angle));
//			enemyBulletAimAngle.add(angle);
//			enemyBulletLife.add(500);
//			enemyBulletSpeed.add(2.0);
//		}
//	}

//	public void shotgunPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "MudMuk") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("MudMuk");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2))));
//				enemyBulletSpeed.add(1.6);
//				enemyBulletLife.add(150);
//			}
//			if (enemyName.get(i) == "Hugsbert") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("Hugsbert");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2))));
//				enemyBulletSpeed.add(1.75);
//				enemyBulletLife.add(250);
//			}
//			// TODO - figure out how to do predictive aim
//		}
//	}

//	public void omnidirectionalPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "SpyEye") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("SpyEye");
//				enemyBulletX.add(enemyX.get(i) + 90);
//				enemyBulletY.add(enemyY.get(i) + 65);
//				enemyBulletW.add(30.0);
//				enemyBulletH.add(30.0);
//				enemyBulletXAngle.add(Math.sin(angle + Math.toRadians(72 * i2)));
//				enemyBulletYAngle.add(Math.cos(angle + Math.toRadians(72 * i2)));
//				enemyBulletAimAngle.add(angle + Math.toRadians(72 * i2));
//				enemyBulletSpeed.add(2.5);
//				enemyBulletLife.add(200);
//			}
//		}
//	}

//	public void bulletCollision() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			for (int i2 = i * 5; i2 >= i * 5 && i2 < (i * 5) + 5 && i2 < enemyShooting.size(); i2++) {
//				if (enemyBulletX.get(i2) < x + 20 && x < enemyBulletX.get(i2) + enemyBulletW.get(i2)
//						&& enemyBulletY.get(i2) < y + 20 && y < enemyBulletY.get(i2) + enemyBulletH.get(i2)) {
//					if (enemyName.get(i) == "SpyEye") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MudMuk") {
//						if ((defenseUp / 4) < 2) {
//							playerHP -= 2 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "Hugsbert") {
//						if ((defenseUp / 4) < 10) {
//							playerHP -= 10 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MadMask") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					}
//					enemyShot.set(i2, false);
//				}
//			}
//		}
//	}

//	public void powerUp(int spawnRate, int i) {
//
//		if (spawnRate == 0 || spawnRate == 1) {
//			powerUp.add(true);
//			powerUpType.add("Health");
//		} else if (spawnRate == 2 || spawnRate == 3) {
//			powerUp.add(true);
//			powerUpType.add("Mana");
//		} else if (spawnRate == 4) {
//			powerUp.add(true);
//			powerUpType.add("Damage");
//		} else if (spawnRate == 5) {
//			powerUp.add(true);
//			powerUpType.add("Defense");
//		}
//		for (int i2 = 0; i2 < powerUp.size(); i2++) {
//			if (powerUp.get(i2) && powerUp.size() > powerUpX.size() && i2 == powerUpX.size()) {
//				int[] enemyX2 = new int[enemyX.size()];
//				int[] enemyY2 = new int[enemyY.size()];
//				enemyX2[i] += enemyX.get(i) + (enemyW.get(i) / 2) - 12;
//				enemyY2[i] += enemyY.get(i) + (enemyH.get(i) / 2) - 12;
//				powerUpX.add(enemyX2[i]);
//				powerUpY.add(enemyY2[i]);
//				// if (powerUp.get(i2) == false) {
//				// powerUpX.remove(i2);
//				// powerUpY.remove(i2);
//				// powerUp.remove(i2);
//				// }
//			}
//		}
//	}

//	public boolean powerUpCollected(int i) {
//		if (x < powerUpX.get(i) + 44 && y < powerUpY.get(i) + 24 && powerUpX.get(i) < x + 24
//				&& powerUpY.get(i) < y + 20) {
//			return true;
//		} else {
//			return false;
//		}
//	}
	
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		
		Graphics2D g2d = (Graphics2D)g;
		
//		drawPowerUpArrow(500, 10, powerUpAnimation, (Color.RED), g);
		
		powerUpAnimation++;
		if (powerUpAnimation == 1000)
			powerUpAnimation = 0;
		for (int i = 0; i < powerUp.size(); i++) {
			powerUp.get(i).draw(g);
//			if (powerUpType.get(i) == "Health")
//				drawHealthUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Mana")
//				drawManaUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Damage")
//				drawDamageUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Defense")
//				drawDefenseUp(powerUpX.get(i), powerUpY.get(i), g);
		}

		drawPreviousDeaths(g);

		g.drawRect(barrierX, barrierY, barrierW, barrierH);

		
		
		drawEnemies(g);
//		
//		for (int i = 0; i < enemyName.size(); i++) {
//			if (enemyName.get(i) == "MadMask") {
//				drawMadMaskBullets(g, g2d);
//			} else if (enemyName.get(i) == "SpyEye") {
//				drawSpyEyeBullets(g, g2d);
//			} else if (enemyName.get(i) == "Hugsbert") {
//				drawHugsbertBullets(g, g2d);
//			} else {
//				drawMudMukBullets(g, g2d);
//			}
//		}

		if (playerAlive) {
			player.draw(g);
		} else {
			drawDeadPlayer(player.getX(), player.getY(), g);
		}

		g.drawString("Personal Best: " + hiScore, 10, 20);
		g.drawString("Kill Count: " + killCount, 10, 40);

		g.drawString("Enemies Alive: " + enemy.size(), 10, 65);
		g.drawString("Regen: " + player.getVitality(), 10, 85);
		g.drawString("Mana Regen: " + player.getWisdom(), 10, 105);
		g.drawString("Damage: " + player.getAttack(), 10, 125);
		g.drawString("Defense: " + player.getDefense(), 10, 145);
		
		drawBullets(g, g2d);
	}
	
	@Override
	public void actionPerformed(ActionEvent e) {
		
		spawning();
		
//		if (manaUp > 20) manaUp = 20; // mana cap
		
		// increases the rate at which the player heals
		regen++;
		if (regen > (1000 - (player.getVitality() * 5)) && player.getHP() < 100) {
			player.setHP(2 + player.getHP());
			regen = 0;
		}
		if (player.getHP() > 100) {
			player.setHP(100);
		}
		for (int i = 0; i < powerUp.size(); i++) {
			if (powerUp.get(i).collected(player.getX(), player.getY(), player.getW(), player.getH())) {
				player.collectPowerUp(powerUp.get(i).getType());
				
				powerUp.remove(i);
			}
		}

		if (player.getHP() <= 0) {
			playerAlive = false;
		}

		if (playerAlive) {
			movement();
			shootingMechanic();
//			bulletCollision();
		} else {
			for (int i = 0; i < playerShot.size(); i++) {
				bulletLife.set(i, -5 + bulletLife.get(i));
				if (playerShot.get(i)) {
					bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
					bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
				}
				if (bulletLife.get(i) <= 0) {
					bulletCleanup(i);
				}
			}
			try {
				recordDeath(player.getRealLocationX(), player.getRealLocationY());
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

		enemyLogic();
//		enemyBulletLogic();
		
		try {
			highScoreWriter(hiScore);
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		

		repaint();
	}

	public void keyPressed(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = true;
		}
		if (key == 'A') {
			left = true;
		}
		if (key == 'S') {
			down = true;
		}
		if (key == 'D') {
			right = true;
		}
		if (key == KeyEvent.VK_SPACE && player.getMana() >= 100) {
			ability = true;
		}
	}
	public void keyReleased(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = false;
		}
		if (key == 'A') {
			left = false;
		}
		if (key == 'S') {
			down = false;
		}
		if (key == 'D') {
			right = false;
		}
		if (key == KeyEvent.VK_SPACE && player.getMana() == 100) {
			ability = false;
		}
	}

	@Override
	public void mouseClicked(MouseEvent e) {
	}
	@Override
	public void mousePressed(MouseEvent e) {
		shooting = true;
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		shooting = false;
	}
	@Override
	public void mouseDragged(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseMoved(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseEntered(MouseEvent e) {

	}
	@Override
	public void mouseExited(MouseEvent e) {

	}

	private void initComponents() {
		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
		this.setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 400, Short.MAX_VALUE));
		layout.setVerticalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 300, Short.MAX_VALUE));
	}

}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-02-02 19:23:25.458
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-02-02 19:23:25.464
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-02-02 19:23:27.003
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package oryx;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

import javax.swing.Timer;

import enemies.Enemies;
import enemies.Hugsbert;
import enemies.MadMask;
import enemies.MudMuk;
import enemies.SpyEye;

import javax.imageio.ImageIO;
import javax.swing.JPanel;

public class Display extends JPanel implements ActionListener, MouseListener, MouseMotionListener {

	// String path = System.getProperty("home.dir");

	/*
	 * SpyEye - fires in all directions MudMuk - fires straight at the player in a
	 * shotgun pattern Hugsbert - predicts where the player will be MadMask -
	 * periodically rapid fires at the player
	 */

	Oryx oryx = new Oryx();
	Player player = new Player((oryx.frame.getWidth() / 2) - 10, (oryx.frame.getHeight() / 2) - 10, 20, 20);
	ArrayList<Enemies> enemy = new ArrayList<Enemies>();
	
	ArrayList<Bullet> bullet = new ArrayList<>
	
	ArrayList<PowerUp> powerUp = new ArrayList<PowerUp>();

//	int x = (oryx.frame.getWidth() / 2) - 10, y = (oryx.frame.getHeight() / 2) - 10;
//	int locationX = x, locationY = y;
	int movementTrackerX = 0, movementTrackerY = 0;

	boolean playerAlive = true;
//	int playerHP = 100;
	boolean up = false, down = false, left = false, right = false;
	boolean shooting = false;

	boolean ability = false;
//	double mana = 100;

	int regen = 0;
	int regenUp = 0;
	int manaUp = 0;
	int damageUp = 0;
	int defenseUp = 0;
	int powerUpAnimation = 0;

	int shootingCounter = 0;

	int hiScore, killCount = 0;

	int mouseX = 0, mouseY = 0;

	int barrierX = -2000, barrierY = -2000, barrierW = 5000, barrierH = 5000;

	int spawnRate;

	String[] enemyNames = { "SpyEye", "MudMuk", "Hugsbert", "MadMask" };
	
	Random random = new Random();

	ArrayList<Boolean> playerShot = new ArrayList<Boolean>();
	ArrayList<Integer> bulletLife = new ArrayList<Integer>();
	ArrayList<Double> bulletX = new ArrayList<Double>();
	ArrayList<Double> bulletY = new ArrayList<Double>();
	ArrayList<Double> bulletXAngle = new ArrayList<Double>();
	ArrayList<Double> bulletYAngle = new ArrayList<Double>();
	ArrayList<Double> bulletAimAngle = new ArrayList<Double>();

//	ArrayList<String> powerUpType = new ArrayList<String>();
//	ArrayList<Integer> powerUpX = new ArrayList<Integer>();
//	ArrayList<Integer> powerUpY = new ArrayList<Integer>();

	ArrayList<Integer> gravesX = new ArrayList<Integer>();
	ArrayList<Integer> gravesY = new ArrayList<Integer>();

	
//	ArrayList<String> enemyName = new ArrayList<String>();
//	ArrayList<Boolean> enemyAlive = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShot = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShooting = new ArrayList<Boolean>();
//	ArrayList<Double> enemyX = new ArrayList<Double>();
//	ArrayList<Double> enemyY = new ArrayList<Double>();
//	ArrayList<Double> enemyW = new ArrayList<Double>();
//	ArrayList<Double> enemyH = new ArrayList<Double>();
//	ArrayList<String> enemyBulletOrigin = new ArrayList<String>();
//	ArrayList<Double> enemyBulletX = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletY = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletW = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletH = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletXAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletYAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletAimAngle = new ArrayList<Double>();
//	ArrayList<Integer> enemyBulletLife = new ArrayList<Integer>();
//	ArrayList<Double> enemyBulletSpeed = new ArrayList<Double>();
//	ArrayList<Integer> enemyShootingCounter = new ArrayList<Integer>();
//	ArrayList<Integer> enemyHP = new ArrayList<Integer>();
//	ArrayList<Integer> enemyDirectionCounter = new ArrayList<Integer>();
//	ArrayList<Double> movementAngleX = new ArrayList<Double>();
//	ArrayList<Double> movementAngleY = new ArrayList<Double>();

	ArrayList<Double> storedX = new ArrayList<Double>();
	ArrayList<Double> storedY = new ArrayList<Double>();
	ArrayList<Double> storedX2 = new ArrayList<Double>();
	ArrayList<Double> storedY2 = new ArrayList<Double>();
	ArrayList<Double> predictiveAimAngle = new ArrayList<Double>();

	Timer t;

	AffineTransform at = new AffineTransform();
	
	BufferedImage playerBullet = null;
	BufferedImage madMaskBullet = null;
	BufferedImage SpyEyeBullet = null;
	BufferedImage HugsbertBullet = null;
	BufferedImage MudMukBullet = null;
	
	// Image player = Toolkit.getDefaultToolkit().getImage(path +
	// "/src/images/BulletHellShip.png");

	public Display() throws IOException {
		initComponents();
		t = new Timer(1, this);
		t.start();

		previousDeaths();
		
		bufferImages();
	}

	public void	bufferImages() {
		try {
		    playerBullet = ImageIO.read(new File("src/images/OryxBullet1.png"));
		} catch (IOException e) { 
		}
		try {
		    madMaskBullet = ImageIO.read(new File("src/images/MadMaskBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    SpyEyeBullet = ImageIO.read(new File("src/images/SpyEyeBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    HugsbertBullet = ImageIO.read(new File("src/images/HugsbertBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    MudMukBullet = ImageIO.read(new File("src/images/MudMukBullet.png"));
		} catch (IOException e) { 
		}
	}
	
	public void highScoreWriter(int highScore) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/hiScore.txt");
		Scanner s = new Scanner(file);
		String line;
		line = s.nextLine();
		highScore = Integer.parseInt(line);
		if (killCount > highScore) {
			highScore = killCount;
			FileWriter output = new FileWriter(file);
			output.write(new Integer(highScore).toString());
			output.close();
		}
		this.hiScore = highScore;
	}

	public void previousDeaths() throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		Scanner s = new Scanner(file);
		if (s.hasNextLine()) {
			String line = s.nextLine();
			String[] coordinates = line.split(" ");
			for (int i = 0; i < coordinates.length; i++) {
				String[] chopped = coordinates[i].split(",");
				gravesX.add(Integer.parseInt(chopped[0]));
				gravesY.add(Integer.parseInt(chopped[1]));
			}
		}

		// while (s.hasNext()) {
		// line = s.nextLine();
		// chopped = line.split(", ");
		// gravesX.add(Integer.parseInt(chopped[0]));
		// gravesY.add(Integer.parseInt(chopped[1]));
		// }
		s.close();
	}

	public void recordDeath(int x, int y) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		FileWriter output = new FileWriter(file);
		for (int i = 0; i < gravesX.size(); i++) {
			output.write(new Integer(gravesX.get(i) + movementTrackerX).toString());
			output.write(",");
			output.write(new Integer(gravesY.get(i) + movementTrackerY).toString());
			output.write(" ");
		}
		output.write(new Integer(x).toString());
		output.write(",");
		output.write(new Integer(y).toString());
		output.write(" ");
		output.close();
	}

	public void drawPreviousDeaths(Graphics g) {
		int[] gravesX2 = new int[gravesX.size()];
		int[] gravesY2 = new int[gravesY.size()];
		for (int i = 0; i < gravesX.size(); i++) {
			gravesX2[i] = gravesX.get(i);
			gravesY2[i] = gravesY.get(i);
			drawDeadPlayer(gravesX2[i], gravesY2[i], g);
		}
	}
	
	public void spawning() {
		
		spawnRate = random.nextInt(500) + 1;

		if (spawnRate == 500) {
			double spawnPointX = random.nextInt((barrierX + barrierW) - 100) + barrierX + 100;
			double spawnPointY = random.nextInt((barrierY + barrierH) - 100) + barrierY + 100;

			String name = enemyNames[random.nextInt(4)];
			
//			0 - SpyEye
//			1 - MudMuk
//			2 - Hugsbert
//			3 - MadMask
			
			switch (name) {
				case "SpyEye" : {
					enemy.add(new SpyEye(spawnPointX, spawnPointY));
					break;
				}
				case "MudMuk" : {
					enemy.add(new MudMuk(spawnPointX, spawnPointY));
					break;
				}
				case "Hugsbert" : {
					enemy.add(new Hugsbert(spawnPointX, spawnPointY));
					break;
				}
				case "MadMask" : {
					enemy.add(new MadMask(spawnPointX, spawnPointY));
					break;
				}
			}
			
//			enemyAlive.add(true);
//			enemyName.add(enemyNames[random.nextInt(4)]);
//			enemyX.add(spawnPointX);
//			enemyY.add(spawnPointY);
//			predictiveAimAngle.add(0.0);
//			enemyShootingCounter.add(0);
//			for (int i = 0; i < enemyAlive.size(); i++) {
//				if (enemyName.get(i) == "SpyEye") {
//					enemyW.add(210.0);
//					enemyH.add(140.0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					enemyW.add(180.0);
//					enemyH.add(160.0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					enemyW.add(156.0);
//					enemyH.add(168.0);
//				} else if (enemyName.get(i) == "MadMask") {
//					enemyW.add(144.0);
//					enemyH.add(160.0);
//				}
//				if (enemyAlive.size() > enemyHP.size() && i == enemyHP.size()) {
//					if (enemyName.get(i) == "SpyEye") {
//						enemyHP.add(500);
//					} else if (enemyName.get(i) == "MudMuk") {
//						enemyHP.add(700);
//					} else if (enemyName.get(i) == "Hugsbert") {
//						enemyHP.add(600);
//					} else if (enemyName.get(i) == "MadMask") {
//						enemyHP.add(500);
//					}
//				}
//			}
		}
	}

	public void drawDeadPlayer(int x, int y, Graphics g) {
		int[] graveX = { x + 4, x + 4, x + 20, x + 20, x + 24, x + 24, x, x };
		int[] graveY = { y + 4, y, y, y + 4, y + 4, y + 28, y + 28, y + 4 };
		Color graveGray = new Color(200, 200, 200);
		g.setColor(graveGray);
		g.fillRect(x, y + 4, 4, 24);
		g.fillRect(x + 4, y, 4, 28);
		g.fillRect(x + 8, y, 4, 28);
		g.fillRect(x + 12, y, 4, 28);
		g.fillRect(x + 16, y, 4, 28);
		Color graveShade = new Color(152, 152, 152);
		g.setColor(graveShade);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 4, y + 16, 12, 4);
		g.fillRect(x + 16, y, 4, 4);
		g.fillRect(x + 20, y + 4, 4, 24);
		g.setColor(Color.BLACK);
		g.drawPolygon(graveX, graveY, 8);
	}

	public void drawBullets(Graphics g, Graphics2D g2d) {
		for (int i = 0; i < playerShot.size(); i++) {
			double[] bulletX2 = new double[bulletX.size()];
			double[] bulletY2 = new double[bulletY.size()];
			bulletX2[i] = bulletX.get(i);
			bulletY2[i] = bulletY.get(i);
			
			at.rotate(-bulletAimAngle.get(i), bulletX2[i] + ((playerBullet.getWidth()*4)/2), bulletY2[i] + ((playerBullet.getHeight()*4) /2));
			g2d.transform(at);
			g2d.drawImage(playerBullet, (int) bulletX2[i] + 5, (int) bulletY2[i] + 5, 12, 20, null);
			
			try{
		        g2d.transform(at.createInverse());
		    }catch(NoninvertibleTransformException e){
		        //...
		    }
			
			at.setToIdentity();
		}
	}

	public void drawEnemies(Graphics g) {
		
		for (int i = 0; i < enemy.size(); i++) {
			enemy.get(i).draw(g);
		}
//		g.setColor(Color.RED);
//
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double[] enemyX2 = new double[enemyX.size()];
//			double[] enemyY2 = new double[enemyY.size()];
//			enemyX2[i] = enemyX.get(i);
//			enemyY2[i] = enemyY.get(i);
//			if (enemyName.get(i) == "SpyEye") {
//	//			enemy.drawSpyEye((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//			} else if (enemyName.get(i) == "MudMuk") {
//	//			enemy.drawMudMuk((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//			} else if (enemyName.get(i) == "Hugsbert") {
//	//			enemy.drawHugsbert((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//			} else if (enemyName.get(i) == "MadMask") {
//	//			enemy.drawMadMask((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//			}
//			// g.fillRect((int) enemyX2[i], (int) enemyY2[i], 50, 50);
//		}
	}
	
//	public void drawMadMaskBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MadMask") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((madMaskBullet.getWidth()*4)/2), enemyBulletY2[i] + ((madMaskBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(madMaskBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    } catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				} 
//				
//				}
//			}
//	}
//
//	public void drawSpyEyeBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "SpyEye") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((SpyEyeBullet.getWidth()*4)/2), enemyBulletY2[i] + ((SpyEyeBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(SpyEyeBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawHugsbertBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "Hugsbert") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((HugsbertBullet.getWidth()*4)/2), enemyBulletY2[i] + ((HugsbertBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(HugsbertBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawMudMukBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MudMuk") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i), enemyBulletX2[i] + ((MudMukBullet.getWidth()*4)/2), enemyBulletY2[i] + ((MudMukBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(MudMukBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
	
//	public void drawHealthUp(int x, int y, Graphics g) {
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y + 4, 4, 12);
//		g.fillRect(x + 4, y, 8, 4);
//		g.fillRect(x + 4, y + 16, 4, 4);
//		g.fillRect(x + 8, y + 20, 4, 4);
//		g.fillRect(x + 12, y + 4, 4, 4);
//		g.fillRect(x + 12, y + 24, 4, 4);
//		g.fillRect(x + 16, y, 8, 4);
//		g.fillRect(x + 16, y + 20, 4, 4);
//		g.fillRect(x + 20, y + 16, 4, 4);
//		g.fillRect(x + 24, y + 4, 4, 12);
//		g.setColor(Color.RED);
//		g.fillRect(x + 4, y + 4, 4, 12);
//		g.fillRect(x + 8, y + 4, 4, 16);
//		g.fillRect(x + 12, y + 8, 4, 16);
//		g.fillRect(x + 16, y + 4, 4, 16);
//		g.fillRect(x + 20, y + 4, 4, 12);
//		g.setColor(Color.WHITE);
//		g.fillRect(x + 20, y + 4, 4, 4);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
//		}
//	}
//
//	public void drawManaUp(int x, int y, Graphics g) {
//		g.setColor(Color.BLUE);
//		g.fillRect(x + 4, y + 4, 20, 20);
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y + 8, 4, 12);
//		g.fillRect(x + 4, y + 4, 4, 4);
//		g.fillRect(x + 4, y + 20, 4, 4);
//		g.fillRect(x + 8, y, 12, 4);
//		g.fillRect(x + 8, y + 24, 12, 4);
//		g.fillRect(x + 20, y + 4, 4, 4);
//		g.fillRect(x + 20, y + 20, 4, 4);
//		g.fillRect(x + 24, y + 8, 4, 12);
//		g.setColor(Color.WHITE);
//		g.fillRect(x + 16, y + 8, 4, 4);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.BLUE, g);
//		}
//	}
//	
//	public void drawDamageUp(int x, int y, Graphics g) {
//		g.setColor(Color.RED);
//		g.fillRect(x + 4, y + 4, 20, 20);
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y + 4, 4, 16);
//		g.fillRect(x + 4, y, 20, 4);
//		g.fillRect(x + 4, y + 12, 12, 4);
//		g.fillRect(x + 4, y + 20, 4, 8);
//		g.fillRect(x + 4, y + 24, 20, 4);
//		g.fillRect(x + 8, y, 4, 16);
//		g.fillRect(x + 16, y, 4, 12);
//		g.fillRect(x + 16, y + 8, 12, 4);
//		g.fillRect(x + 24, y + 4, 4, 16);
//		g.fillRect(x + 16, y + 16, 4, 4);
//		g.fillRect(x + 20, y + 20, 4, 4);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
//		}
//	}
//	
//	public void drawDefenseUp(int x, int y, Graphics g) {
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y, 4, 16);
//		g.fillRect(x, y, 32, 4);
//		g.fillRect(x + 4, y + 16, 4, 4);
//		g.fillRect(x + 8, y + 20, 4, 4);
//		g.fillRect(x + 12, y + 24, 8, 4);
//		g.fillRect(x + 20, y + 20, 4, 4);
//		g.fillRect(x + 24, y + 16, 4, 4);
//		g.fillRect(x + 28, y, 4, 16);
//		Color shieldShade = new Color(130, 130, 130);
//		g.setColor(shieldShade);
//		g.fillRect(x + 4, y + 4, 12, 12);
//		g.fillRect(x + 8, y + 16, 8, 4);
//		g.fillRect(x + 12, y + 20, 4, 4);
//		Color shield = new Color(201, 201, 201);
//		g.setColor(shield);
//		g.fillRect(x + 16, y + 20, 4, 4);
//		g.fillRect(x + 16, y + 16, 8, 4);
//		g.fillRect(x + 16, y + 4, 12, 12);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, shield, g);
//		}
//	}
	
	public void drawPowerUpArrow(int x, int y, int counter, Color color, Graphics g) {
		if (counter > 500 && counter < 1000) {
			y += 4;
		}
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 8, 4, 4);
		g.fillRect(x + 4, y + 4, 4, 4);
		g.fillRect(x + 4, y + 12, 4, 12);
		g.fillRect(x + 8, y, 4, 4);
		g.fillRect(x + 8, y + 20, 4, 4);
		g.fillRect(x + 12, y + 4, 4, 4);
		g.fillRect(x + 12, y + 12, 4, 12);
		g.fillRect(x + 16, y + 8, 4, 4);
		g.setColor(color);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 8, y + 4, 4, 16);
	}

	public void movement() {
		if (up == true) {
			if (player.getY() > barrierY) {
				barrierY++;
				player.setRealLocationY(-1 + player.getRealLocationY());
				movementTrackerY--;

				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, 1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, 1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(1 + powerUp.get(i).getY());
				}
			}
		}

		if (down == true) {
			// y++;
			if (player.getY() < barrierY + barrierH - 20) {
				barrierY--;
				//locationY++;
				player.setRealLocationY(1 + player.getRealLocationY());
				movementTrackerY++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, -1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, -1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(-1 + powerUp.get(i).getY());
				}
			}
		}
		if (left == true) {
			//x--;
			if (player.getX() > barrierX) {
				barrierX++;
				player.setRealLocationX(-1 + player.getRealLocationX());
				movementTrackerX--;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, 1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesX.set(i, 1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(1 + powerUp.get(i).getX());
				}
			}
		}
		if (right == true) {
			// x++;
			if (player.getX() < barrierX + barrierW - 20) {
				barrierX--;
				player.setRealLocationX(1 + player.getRealLocationX());
				movementTrackerX++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, -1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesX.size(); i++) {
					gravesX.set(i, -1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(-1 + powerUp.get(i).getX());
				}
			}
		}

		for (int i = 0; i < playerShot.size(); i++) {
			if (up) {
				bulletY.set(i, 1 + bulletY.get(i));
			}
			if (down) {
				bulletY.set(i, -1 + bulletY.get(i));
			}
			if (left) {
				bulletX.set(i, 1 + bulletX.get(i));
			}
			if (right) {
				bulletX.set(i, -1 + bulletX.get(i));
			}
		}
	}

	public void shootingMechanic() {

		double angle = Math.atan2((player.getX() + 15) - mouseX, (player.getY() + 35) - mouseY);
		
		if (shooting == true) {
			shootingCounter++;
			if (shootingCounter == 1) {
				playerShot.add(true);
				bulletLife.add(950);
				bulletX.add((double) player.getX());
				bulletY.add((double) player.getY());
				bulletXAngle.add(Math.sin(angle));
				bulletYAngle.add(Math.cos(angle));
				bulletAimAngle.add(angle);
			}
			if (shootingCounter == 50)
				shootingCounter = 0;
		} else {
			shootingCounter = 0;
		}

		for (int i = 0; i < playerShot.size(); i++) {
			bulletLife.set(i, -5 + bulletLife.get(i));
			if (playerShot.get(i)) {
				bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
				bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
			}
			if (bulletLife.get(i) <= 0) {
				bulletCleanup(i);
			}
		}
		if (ability) {
			abilityMechanic();
		} else if (player.getMana() < 100) {
			player.setMana(player.getMana() + 0.025 + (manaUp * 0.00625));
		}
	}

	public void abilityMechanic() {
		player.setMana(0);;
		for (int i = 0; i < 30; i++) {
			double angle = Math.toRadians(0 + (i * 12));
			bulletXAngle.add(Math.sin(angle));
			bulletYAngle.add(Math.cos(angle));
			bulletAimAngle.add(angle);
			playerShot.add(true);
			bulletLife.add(950);
			bulletX.add((double) mouseX);
			bulletY.add((double) mouseY);
		}
		ability = false;
	}

	public void enemyLogic() {
//
		for (int i = 0; i < enemy.size(); i++) {
			
			enemy.get(i).movement(player.getX(), player.getY());
			
			enemy.get(i).aggro(player.getX(), player.getY(), 20, 20);
			
			for (int i2 = 0; i2 < playerShot.size(); i2++) {
				if (enemyHit(i, i2)) {
					bulletCleanup(i2);
					enemy.get(i).setHP((-(player.getAttack() * 2)) + enemy.get(i).getHP());
				}
			}
//			if (enemyAlive.size() > 0) {
//				enemyMovement(enemyX, enemyY, enemyW, enemyH, i);
//				predictiveAiming(i);
//			}
//
//			if (enemyAlive.size() > 100) {
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
			
			if (enemy.get(i).getHP() <= 0) {
				int rando = random.nextInt(23)+1;
				// should be a 25% chance to get a power up 
				switch (rando) {
					case 1 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Vitality"));
						break;
					}
					case 2 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Vitality"));
						break;
					}
					case 3 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Attack"));
						break;
					}
					case 4 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Attack"));
						break;
					}
					case 5 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Defense"));
						break;
					}
					case 6 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Wisdom"));
						break;
					}
					default : {
						System.out.println("Nope, " + rando);
					}
				}
				enemy.remove(i);
				killCount++;
				System.out.println("Rando: " + rando);
			}
//
//			if (enemyHP.get(i) <= 0)
//				enemyAlive.set(i, false);
//			if (enemyAlive.get(i) == false) {
//					killCount++;
//					int powerUpSpawn = random.nextInt(11); //TODO
//					powerUp(powerUpSpawn, i);
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
		}
	}

//	public void enemyMovement(ArrayList<Double> x, ArrayList<Double> y, ArrayList<Double> w, ArrayList<Double> h,
//			int i) {
//		if (enemyAlive.size() > enemyDirectionCounter.size()) {
//			enemyDirectionCounter.add(0);
//		}
//		enemyDirectionCounter.set(i, 1 + enemyDirectionCounter.get(i));
//		if (enemyDirectionCounter.get(i) == 1) {
//			int direction = random.nextInt(359);
//			double angle = direction;
//			double angle2 = Math.atan2((enemyX.get(i) + 85) - (this.x - 10), (y.get(i) + 70) - this.y);
//			if (movementAngleX.size() < enemyAlive.size()) {
//				movementAngleX.add(Math.sin(angle));
//				movementAngleY.add(Math.cos(angle));
//			} else {
////				if (playerAlive && x.get(i) < 1000 && y.get(i) < 650 && 0 < x.get(i) + w.get(i)
////						&& 0 < y.get(i) + h.get(i)) {
//					movementAngleX.set(i, (Math.sin(angle) + Math.sin(angle2)));
//					movementAngleY.set(i, (Math.cos(angle) + Math.cos(angle2)));
////				} else {
////					movementAngleX.set(i, Math.sin(angle));
////					movementAngleY.set(i, Math.cos(angle));
////				}
//			}
//		}
//		if (enemyDirectionCounter.get(i) < 50) {
//			x.set(i, x.get(i) - movementAngleX.get(i) * 0.125);
//			y.set(i, y.g et(i) - movementAngleY.get(i) * 0.125);
//		} else if (enemyDirectionCounter.get(i) >= 50) {
//			enemyDirectionCounter.set(i, 0);
//		}
//	}

	public boolean enemyHit(int i, int i2) {
		if (enemy.size() > 0) {
			if (bulletX.get(i2) < (enemy.get(i).getX() + 130.0) + 40.0 && enemy.get(i).getX() + 40.0 < bulletX.get(i2) + 10
					&& bulletY.get(i2) < (enemy.get(i).getY() + 130.0) + 10 && enemy.get(i).getY() < bulletY.get(i2) + 10) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	public void bulletCleanup(int i) {
		playerShot.remove(i);
		bulletLife.remove(i);
		bulletX.remove(i);
		bulletY.remove(i);
		bulletXAngle.remove(i);
		bulletYAngle.remove(i);
		bulletAimAngle.remove(i);
	}

//	public void enemyBulletLogic() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double angle = Math.atan2((enemyX.get(i) + 85) - (x - 10), (enemyY.get(i) + 70) - y);
//			enemyShootingCounter.set(i, 1 + enemyShootingCounter.get(i));
//			if (enemyShootingCounter.get(i) == 400 && enemyName.get(i) == "SpyEye"
//					|| enemyShootingCounter.get(i) == 500 && enemyName.get(i) == "MudMuk"
//					|| enemyShootingCounter.get(i) == 450 && enemyName.get(i) == "Hugsbert"
//					|| enemyName.get(i) == "MadMask") {
//				if (enemyName.get(i) == "SpyEye") {
//					omnidirectionalPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					shotgunPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					predictiveAimAngle.set(i, predictiveAim(x, y, enemyX.get(i), enemyY.get(i), angle, i));
//					shotgunPattern(predictiveAimAngle.get(i), i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MadMask") {
//					if (enemyShootingCounter.get(i) == 50 || enemyShootingCounter.get(i) == 100
//							|| enemyShootingCounter.get(i) == 150 || enemyShootingCounter.get(i) == 200
//							|| enemyShootingCounter.get(i) == 250)
//						genericPattern(angle, i);
//					else if (enemyShootingCounter.get(i) == 450)
//						enemyShootingCounter.set(i, 0);
//				}
//			}
//		}
//		for (int i2 = 0; i2 < enemyShooting.size(); i2++) {
//			bulletMovement(i2);
//		}
//	}

//	public void bulletMovement(int i) {
//		enemyBulletLife.set(i, -1 + enemyBulletLife.get(i));
//		enemyBulletX.set(i, enemyBulletX.get(i) - enemyBulletXAngle.get(i) * enemyBulletSpeed.get(i));
//		enemyBulletY.set(i, enemyBulletY.get(i) - enemyBulletYAngle.get(i) * enemyBulletSpeed.get(i));
//
//		if (enemyBulletLife.get(i) <= 0 || enemyShot.get(i) == false) {
//			enemyBulletOrigin.remove(i);
//			enemyBulletX.remove(i);
//			enemyBulletY.remove(i);
//			enemyBulletW.remove(i);
//			enemyBulletH.remove(i);
//			enemyBulletXAngle.remove(i);
//			enemyBulletYAngle.remove(i);
//			enemyBulletAimAngle.remove(i);
//			enemyBulletSpeed.remove(i);
//			enemyShooting.remove(i);
//			enemyShot.remove(i);
//			enemyBulletLife.remove(i);
//		}
//	}

	public double predictiveAim(int x, int y, double ex, double ey, double angle, int i) {
		double calculationX = ((storedX.get(i) - storedX2.get(i)) * -1) * 50;
		double calculationY = ((storedY.get(i) - storedY2.get(i)) * -1) * 50;
		// System.out.println(i + ": "+ storedX.get(i));
		// System.out.println((i+1) + ": "+ storedX.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationX);
		// System.out.println(i + ": "+ storedY.get(i));
		// System.out.println((i+1) + ": "+ storedY.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationY);
		// System.out.println(calculationX + ", " + calculationY);
		angle = Math.atan2((ex + 85) - ((x - 10) + calculationX), (ey + 70) - ((y - 10) + calculationY));
		// System.out.println(Math.toDegrees(angle));
		return angle;
	}

//	public void predictiveAiming(int i) {
//		if (storedX.size() < enemyAlive.size()) {
//			storedX.add(i, (double) movementTrackerX);
//			storedY.add(i, (double) movementTrackerY);
//			storedX2.add(i, (double) movementTrackerX);
//			storedY2.add(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 445) {
//			storedX.set(i, (double) movementTrackerX);
//			storedY.set(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 449) {
//			storedX2.set(i, (double) movementTrackerX);
//			storedY2.set(i, (double) movementTrackerY);
//		}
//	}

//	public void genericPattern(double angle, int i) {
//		if (enemyName.get(i) == "MadMask") {
//			enemyShooting.add(true);
//			enemyShot.add(true);
//			enemyBulletOrigin.add("MadMask");
//			enemyBulletX.add(enemyX.get(i) + 59.5);
//			enemyBulletY.add(enemyY.get(i) + 63.5);
//			enemyBulletW.add(25.0);
//			enemyBulletH.add(25.0);
//			enemyBulletXAngle.add(Math.sin(angle));
//			enemyBulletYAngle.add(Math.cos(angle));
//			enemyBulletAimAngle.add(angle);
//			enemyBulletLife.add(500);
//			enemyBulletSpeed.add(2.0);
//		}
//	}

//	public void shotgunPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "MudMuk") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("MudMuk");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2))));
//				enemyBulletSpeed.add(1.6);
//				enemyBulletLife.add(150);
//			}
//			if (enemyName.get(i) == "Hugsbert") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("Hugsbert");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2))));
//				enemyBulletSpeed.add(1.75);
//				enemyBulletLife.add(250);
//			}
//			// TODO - figure out how to do predictive aim
//		}
//	}

//	public void omnidirectionalPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "SpyEye") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("SpyEye");
//				enemyBulletX.add(enemyX.get(i) + 90);
//				enemyBulletY.add(enemyY.get(i) + 65);
//				enemyBulletW.add(30.0);
//				enemyBulletH.add(30.0);
//				enemyBulletXAngle.add(Math.sin(angle + Math.toRadians(72 * i2)));
//				enemyBulletYAngle.add(Math.cos(angle + Math.toRadians(72 * i2)));
//				enemyBulletAimAngle.add(angle + Math.toRadians(72 * i2));
//				enemyBulletSpeed.add(2.5);
//				enemyBulletLife.add(200);
//			}
//		}
//	}

//	public void bulletCollision() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			for (int i2 = i * 5; i2 >= i * 5 && i2 < (i * 5) + 5 && i2 < enemyShooting.size(); i2++) {
//				if (enemyBulletX.get(i2) < x + 20 && x < enemyBulletX.get(i2) + enemyBulletW.get(i2)
//						&& enemyBulletY.get(i2) < y + 20 && y < enemyBulletY.get(i2) + enemyBulletH.get(i2)) {
//					if (enemyName.get(i) == "SpyEye") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MudMuk") {
//						if ((defenseUp / 4) < 2) {
//							playerHP -= 2 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "Hugsbert") {
//						if ((defenseUp / 4) < 10) {
//							playerHP -= 10 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MadMask") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					}
//					enemyShot.set(i2, false);
//				}
//			}
//		}
//	}

//	public void powerUp(int spawnRate, int i) {
//
//		if (spawnRate == 0 || spawnRate == 1) {
//			powerUp.add(true);
//			powerUpType.add("Health");
//		} else if (spawnRate == 2 || spawnRate == 3) {
//			powerUp.add(true);
//			powerUpType.add("Mana");
//		} else if (spawnRate == 4) {
//			powerUp.add(true);
//			powerUpType.add("Damage");
//		} else if (spawnRate == 5) {
//			powerUp.add(true);
//			powerUpType.add("Defense");
//		}
//		for (int i2 = 0; i2 < powerUp.size(); i2++) {
//			if (powerUp.get(i2) && powerUp.size() > powerUpX.size() && i2 == powerUpX.size()) {
//				int[] enemyX2 = new int[enemyX.size()];
//				int[] enemyY2 = new int[enemyY.size()];
//				enemyX2[i] += enemyX.get(i) + (enemyW.get(i) / 2) - 12;
//				enemyY2[i] += enemyY.get(i) + (enemyH.get(i) / 2) - 12;
//				powerUpX.add(enemyX2[i]);
//				powerUpY.add(enemyY2[i]);
//				// if (powerUp.get(i2) == false) {
//				// powerUpX.remove(i2);
//				// powerUpY.remove(i2);
//				// powerUp.remove(i2);
//				// }
//			}
//		}
//	}

//	public boolean powerUpCollected(int i) {
//		if (x < powerUpX.get(i) + 44 && y < powerUpY.get(i) + 24 && powerUpX.get(i) < x + 24
//				&& powerUpY.get(i) < y + 20) {
//			return true;
//		} else {
//			return false;
//		}
//	}
	
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		
		Graphics2D g2d = (Graphics2D)g;
		
//		drawPowerUpArrow(500, 10, powerUpAnimation, (Color.RED), g);
		
		powerUpAnimation++;
		if (powerUpAnimation == 1000)
			powerUpAnimation = 0;
		for (int i = 0; i < powerUp.size(); i++) {
			powerUp.get(i).draw(g);
//			if (powerUpType.get(i) == "Health")
//				drawHealthUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Mana")
//				drawManaUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Damage")
//				drawDamageUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Defense")
//				drawDefenseUp(powerUpX.get(i), powerUpY.get(i), g);
		}

		drawPreviousDeaths(g);

		g.drawRect(barrierX, barrierY, barrierW, barrierH);

		
		
		drawEnemies(g);
//		
//		for (int i = 0; i < enemyName.size(); i++) {
//			if (enemyName.get(i) == "MadMask") {
//				drawMadMaskBullets(g, g2d);
//			} else if (enemyName.get(i) == "SpyEye") {
//				drawSpyEyeBullets(g, g2d);
//			} else if (enemyName.get(i) == "Hugsbert") {
//				drawHugsbertBullets(g, g2d);
//			} else {
//				drawMudMukBullets(g, g2d);
//			}
//		}

		if (playerAlive) {
			player.draw(g);
		} else {
			drawDeadPlayer(player.getX(), player.getY(), g);
		}

		g.drawString("Personal Best: " + hiScore, 10, 20);
		g.drawString("Kill Count: " + killCount, 10, 40);

		g.drawString("Enemies Alive: " + enemy.size(), 10, 65);
		g.drawString("Regen: " + player.getVitality(), 10, 85);
		g.drawString("Mana Regen: " + player.getWisdom(), 10, 105);
		g.drawString("Damage: " + player.getAttack(), 10, 125);
		g.drawString("Defense: " + player.getDefense(), 10, 145);
		
		drawBullets(g, g2d);
	}
	
	@Override
	public void actionPerformed(ActionEvent e) {
		
		spawning();
		
//		if (manaUp > 20) manaUp = 20; // mana cap
		
		// increases the rate at which the player heals
		regen++;
		if (regen > (1000 - (player.getVitality() * 5)) && player.getHP() < 100) {
			player.setHP(2 + player.getHP());
			regen = 0;
		}
		if (player.getHP() > 100) {
			player.setHP(100);
		}
		for (int i = 0; i < powerUp.size(); i++) {
			if (powerUp.get(i).collected(player.getX(), player.getY(), player.getW(), player.getH())) {
				player.collectPowerUp(powerUp.get(i).getType());
				
				powerUp.remove(i);
			}
		}

		if (player.getHP() <= 0) {
			playerAlive = false;
		}

		if (playerAlive) {
			movement();
			shootingMechanic();
//			bulletCollision();
		} else {
			for (int i = 0; i < playerShot.size(); i++) {
				bulletLife.set(i, -5 + bulletLife.get(i));
				if (playerShot.get(i)) {
					bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
					bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
				}
				if (bulletLife.get(i) <= 0) {
					bulletCleanup(i);
				}
			}
			try {
				recordDeath(player.getRealLocationX(), player.getRealLocationY());
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

		enemyLogic();
//		enemyBulletLogic();
		
		try {
			highScoreWriter(hiScore);
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		

		repaint();
	}

	public void keyPressed(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = true;
		}
		if (key == 'A') {
			left = true;
		}
		if (key == 'S') {
			down = true;
		}
		if (key == 'D') {
			right = true;
		}
		if (key == KeyEvent.VK_SPACE && player.getMana() >= 100) {
			ability = true;
		}
	}
	public void keyReleased(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = false;
		}
		if (key == 'A') {
			left = false;
		}
		if (key == 'S') {
			down = false;
		}
		if (key == 'D') {
			right = false;
		}
		if (key == KeyEvent.VK_SPACE && player.getMana() == 100) {
			ability = false;
		}
	}

	@Override
	public void mouseClicked(MouseEvent e) {
	}
	@Override
	public void mousePressed(MouseEvent e) {
		shooting = true;
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		shooting = false;
	}
	@Override
	public void mouseDragged(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseMoved(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseEntered(MouseEvent e) {

	}
	@Override
	public void mouseExited(MouseEvent e) {

	}

	private void initComponents() {
		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
		this.setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 400, Short.MAX_VALUE));
		layout.setVerticalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 300, Short.MAX_VALUE));
	}

}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-02-02 19:23:27.012
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-02-02 19:23:27.019
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-02-02 19:23:29.540
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package oryx;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.geom.AffineTransform;
import java.awt.geom.NoninvertibleTransformException;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;
import java.util.Scanner;

import javax.swing.Timer;

import enemies.Enemies;
import enemies.Hugsbert;
import enemies.MadMask;
import enemies.MudMuk;
import enemies.SpyEye;

import javax.imageio.ImageIO;
import javax.swing.JPanel;

public class Display extends JPanel implements ActionListener, MouseListener, MouseMotionListener {

	// String path = System.getProperty("home.dir");

	/*
	 * SpyEye - fires in all directions MudMuk - fires straight at the player in a
	 * shotgun pattern Hugsbert - predicts where the player will be MadMask -
	 * periodically rapid fires at the player
	 */

	Oryx oryx = new Oryx();
	Player player = new Player((oryx.frame.getWidth() / 2) - 10, (oryx.frame.getHeight() / 2) - 10, 20, 20);
	ArrayList<Enemies> enemy = new ArrayList<Enemies>();
	
	ArrayList<Bullet> bullet = new ArrayList<Bullet>
	
	ArrayList<PowerUp> powerUp = new ArrayList<PowerUp>();

//	int x = (oryx.frame.getWidth() / 2) - 10, y = (oryx.frame.getHeight() / 2) - 10;
//	int locationX = x, locationY = y;
	int movementTrackerX = 0, movementTrackerY = 0;

	boolean playerAlive = true;
//	int playerHP = 100;
	boolean up = false, down = false, left = false, right = false;
	boolean shooting = false;

	boolean ability = false;
//	double mana = 100;

	int regen = 0;
	int regenUp = 0;
	int manaUp = 0;
	int damageUp = 0;
	int defenseUp = 0;
	int powerUpAnimation = 0;

	int shootingCounter = 0;

	int hiScore, killCount = 0;

	int mouseX = 0, mouseY = 0;

	int barrierX = -2000, barrierY = -2000, barrierW = 5000, barrierH = 5000;

	int spawnRate;

	String[] enemyNames = { "SpyEye", "MudMuk", "Hugsbert", "MadMask" };
	
	Random random = new Random();

	ArrayList<Boolean> playerShot = new ArrayList<Boolean>();
	ArrayList<Integer> bulletLife = new ArrayList<Integer>();
	ArrayList<Double> bulletX = new ArrayList<Double>();
	ArrayList<Double> bulletY = new ArrayList<Double>();
	ArrayList<Double> bulletXAngle = new ArrayList<Double>();
	ArrayList<Double> bulletYAngle = new ArrayList<Double>();
	ArrayList<Double> bulletAimAngle = new ArrayList<Double>();

//	ArrayList<String> powerUpType = new ArrayList<String>();
//	ArrayList<Integer> powerUpX = new ArrayList<Integer>();
//	ArrayList<Integer> powerUpY = new ArrayList<Integer>();

	ArrayList<Integer> gravesX = new ArrayList<Integer>();
	ArrayList<Integer> gravesY = new ArrayList<Integer>();

	
//	ArrayList<String> enemyName = new ArrayList<String>();
//	ArrayList<Boolean> enemyAlive = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShot = new ArrayList<Boolean>();
//	ArrayList<Boolean> enemyShooting = new ArrayList<Boolean>();
//	ArrayList<Double> enemyX = new ArrayList<Double>();
//	ArrayList<Double> enemyY = new ArrayList<Double>();
//	ArrayList<Double> enemyW = new ArrayList<Double>();
//	ArrayList<Double> enemyH = new ArrayList<Double>();
//	ArrayList<String> enemyBulletOrigin = new ArrayList<String>();
//	ArrayList<Double> enemyBulletX = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletY = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletW = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletH = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletXAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletYAngle = new ArrayList<Double>();
//	ArrayList<Double> enemyBulletAimAngle = new ArrayList<Double>();
//	ArrayList<Integer> enemyBulletLife = new ArrayList<Integer>();
//	ArrayList<Double> enemyBulletSpeed = new ArrayList<Double>();
//	ArrayList<Integer> enemyShootingCounter = new ArrayList<Integer>();
//	ArrayList<Integer> enemyHP = new ArrayList<Integer>();
//	ArrayList<Integer> enemyDirectionCounter = new ArrayList<Integer>();
//	ArrayList<Double> movementAngleX = new ArrayList<Double>();
//	ArrayList<Double> movementAngleY = new ArrayList<Double>();

	ArrayList<Double> storedX = new ArrayList<Double>();
	ArrayList<Double> storedY = new ArrayList<Double>();
	ArrayList<Double> storedX2 = new ArrayList<Double>();
	ArrayList<Double> storedY2 = new ArrayList<Double>();
	ArrayList<Double> predictiveAimAngle = new ArrayList<Double>();

	Timer t;

	AffineTransform at = new AffineTransform();
	
	BufferedImage playerBullet = null;
	BufferedImage madMaskBullet = null;
	BufferedImage SpyEyeBullet = null;
	BufferedImage HugsbertBullet = null;
	BufferedImage MudMukBullet = null;
	
	// Image player = Toolkit.getDefaultToolkit().getImage(path +
	// "/src/images/BulletHellShip.png");

	public Display() throws IOException {
		initComponents();
		t = new Timer(1, this);
		t.start();

		previousDeaths();
		
		bufferImages();
	}

	public void	bufferImages() {
		try {
		    playerBullet = ImageIO.read(new File("src/images/OryxBullet1.png"));
		} catch (IOException e) { 
		}
		try {
		    madMaskBullet = ImageIO.read(new File("src/images/MadMaskBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    SpyEyeBullet = ImageIO.read(new File("src/images/SpyEyeBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    HugsbertBullet = ImageIO.read(new File("src/images/HugsbertBullet.png"));
		} catch (IOException e) { 
		}
		try {
		    MudMukBullet = ImageIO.read(new File("src/images/MudMukBullet.png"));
		} catch (IOException e) { 
		}
	}
	
	public void highScoreWriter(int highScore) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/hiScore.txt");
		Scanner s = new Scanner(file);
		String line;
		line = s.nextLine();
		highScore = Integer.parseInt(line);
		if (killCount > highScore) {
			highScore = killCount;
			FileWriter output = new FileWriter(file);
			output.write(new Integer(highScore).toString());
			output.close();
		}
		this.hiScore = highScore;
	}

	public void previousDeaths() throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		Scanner s = new Scanner(file);
		if (s.hasNextLine()) {
			String line = s.nextLine();
			String[] coordinates = line.split(" ");
			for (int i = 0; i < coordinates.length; i++) {
				String[] chopped = coordinates[i].split(",");
				gravesX.add(Integer.parseInt(chopped[0]));
				gravesY.add(Integer.parseInt(chopped[1]));
			}
		}

		// while (s.hasNext()) {
		// line = s.nextLine();
		// chopped = line.split(", ");
		// gravesX.add(Integer.parseInt(chopped[0]));
		// gravesY.add(Integer.parseInt(chopped[1]));
		// }
		s.close();
	}

	public void recordDeath(int x, int y) throws IOException {
		String path = System.getProperty("user.dir");
		File file = new File(path + "/src/oryx/deadPlayers.txt");
		FileWriter output = new FileWriter(file);
		for (int i = 0; i < gravesX.size(); i++) {
			output.write(new Integer(gravesX.get(i) + movementTrackerX).toString());
			output.write(",");
			output.write(new Integer(gravesY.get(i) + movementTrackerY).toString());
			output.write(" ");
		}
		output.write(new Integer(x).toString());
		output.write(",");
		output.write(new Integer(y).toString());
		output.write(" ");
		output.close();
	}

	public void drawPreviousDeaths(Graphics g) {
		int[] gravesX2 = new int[gravesX.size()];
		int[] gravesY2 = new int[gravesY.size()];
		for (int i = 0; i < gravesX.size(); i++) {
			gravesX2[i] = gravesX.get(i);
			gravesY2[i] = gravesY.get(i);
			drawDeadPlayer(gravesX2[i], gravesY2[i], g);
		}
	}
	
	public void spawning() {
		
		spawnRate = random.nextInt(500) + 1;

		if (spawnRate == 500) {
			double spawnPointX = random.nextInt((barrierX + barrierW) - 100) + barrierX + 100;
			double spawnPointY = random.nextInt((barrierY + barrierH) - 100) + barrierY + 100;

			String name = enemyNames[random.nextInt(4)];
			
//			0 - SpyEye
//			1 - MudMuk
//			2 - Hugsbert
//			3 - MadMask
			
			switch (name) {
				case "SpyEye" : {
					enemy.add(new SpyEye(spawnPointX, spawnPointY));
					break;
				}
				case "MudMuk" : {
					enemy.add(new MudMuk(spawnPointX, spawnPointY));
					break;
				}
				case "Hugsbert" : {
					enemy.add(new Hugsbert(spawnPointX, spawnPointY));
					break;
				}
				case "MadMask" : {
					enemy.add(new MadMask(spawnPointX, spawnPointY));
					break;
				}
			}
			
//			enemyAlive.add(true);
//			enemyName.add(enemyNames[random.nextInt(4)]);
//			enemyX.add(spawnPointX);
//			enemyY.add(spawnPointY);
//			predictiveAimAngle.add(0.0);
//			enemyShootingCounter.add(0);
//			for (int i = 0; i < enemyAlive.size(); i++) {
//				if (enemyName.get(i) == "SpyEye") {
//					enemyW.add(210.0);
//					enemyH.add(140.0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					enemyW.add(180.0);
//					enemyH.add(160.0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					enemyW.add(156.0);
//					enemyH.add(168.0);
//				} else if (enemyName.get(i) == "MadMask") {
//					enemyW.add(144.0);
//					enemyH.add(160.0);
//				}
//				if (enemyAlive.size() > enemyHP.size() && i == enemyHP.size()) {
//					if (enemyName.get(i) == "SpyEye") {
//						enemyHP.add(500);
//					} else if (enemyName.get(i) == "MudMuk") {
//						enemyHP.add(700);
//					} else if (enemyName.get(i) == "Hugsbert") {
//						enemyHP.add(600);
//					} else if (enemyName.get(i) == "MadMask") {
//						enemyHP.add(500);
//					}
//				}
//			}
		}
	}

	public void drawDeadPlayer(int x, int y, Graphics g) {
		int[] graveX = { x + 4, x + 4, x + 20, x + 20, x + 24, x + 24, x, x };
		int[] graveY = { y + 4, y, y, y + 4, y + 4, y + 28, y + 28, y + 4 };
		Color graveGray = new Color(200, 200, 200);
		g.setColor(graveGray);
		g.fillRect(x, y + 4, 4, 24);
		g.fillRect(x + 4, y, 4, 28);
		g.fillRect(x + 8, y, 4, 28);
		g.fillRect(x + 12, y, 4, 28);
		g.fillRect(x + 16, y, 4, 28);
		Color graveShade = new Color(152, 152, 152);
		g.setColor(graveShade);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 4, y + 16, 12, 4);
		g.fillRect(x + 16, y, 4, 4);
		g.fillRect(x + 20, y + 4, 4, 24);
		g.setColor(Color.BLACK);
		g.drawPolygon(graveX, graveY, 8);
	}

	public void drawBullets(Graphics g, Graphics2D g2d) {
		for (int i = 0; i < playerShot.size(); i++) {
			double[] bulletX2 = new double[bulletX.size()];
			double[] bulletY2 = new double[bulletY.size()];
			bulletX2[i] = bulletX.get(i);
			bulletY2[i] = bulletY.get(i);
			
			at.rotate(-bulletAimAngle.get(i), bulletX2[i] + ((playerBullet.getWidth()*4)/2), bulletY2[i] + ((playerBullet.getHeight()*4) /2));
			g2d.transform(at);
			g2d.drawImage(playerBullet, (int) bulletX2[i] + 5, (int) bulletY2[i] + 5, 12, 20, null);
			
			try{
		        g2d.transform(at.createInverse());
		    }catch(NoninvertibleTransformException e){
		        //...
		    }
			
			at.setToIdentity();
		}
	}

	public void drawEnemies(Graphics g) {
		
		for (int i = 0; i < enemy.size(); i++) {
			enemy.get(i).draw(g);
		}
//		g.setColor(Color.RED);
//
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double[] enemyX2 = new double[enemyX.size()];
//			double[] enemyY2 = new double[enemyY.size()];
//			enemyX2[i] = enemyX.get(i);
//			enemyY2[i] = enemyY.get(i);
//			if (enemyName.get(i) == "SpyEye") {
//	//			enemy.drawSpyEye((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 55, (int) enemyY2[i] + 150, enemyHP.get(i) / 5, 10);
//			} else if (enemyName.get(i) == "MudMuk") {
//	//			enemy.drawMudMuk((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 40, (int) enemyY2[i] + 170, enemyHP.get(i) / 7, 10);
//			} else if (enemyName.get(i) == "Hugsbert") {
//	//			enemy.drawHugsbert((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 28, (int) enemyY2[i] + 178, enemyHP.get(i) / 6, 10);
//			} else if (enemyName.get(i) == "MadMask") {
//	//			enemy.drawMadMask((int) enemyX2[i], (int) enemyY2[i], g);
//				g.setColor(Color.RED);
//				g.fillRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//				g.setColor(Color.BLACK);
//				g.drawRect((int) enemyX2[i] + 22, (int) enemyY2[i] + 178, enemyHP.get(i) / 5, 10);
//			}
//			// g.fillRect((int) enemyX2[i], (int) enemyY2[i], 50, 50);
//		}
	}
	
//	public void drawMadMaskBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MadMask") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((madMaskBullet.getWidth()*4)/2), enemyBulletY2[i] + ((madMaskBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(madMaskBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    } catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				} 
//				
//				}
//			}
//	}
//
//	public void drawSpyEyeBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "SpyEye") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((SpyEyeBullet.getWidth()*4)/2), enemyBulletY2[i] + ((SpyEyeBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(SpyEyeBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawHugsbertBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "Hugsbert") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i) + Math.toRadians(-45), enemyBulletX2[i] + ((HugsbertBullet.getWidth()*4)/2), enemyBulletY2[i] + ((HugsbertBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(HugsbertBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
//
//	public void drawMudMukBullets(Graphics g, Graphics2D g2d) {
//		for (int i = 0; i < enemyShot.size(); i++) {
//			if (enemyShot.get(i) && enemyBulletOrigin.get(i) == "MudMuk") {
//				double[] enemyBulletX2 = new double[enemyBulletX.size()];
//				double[] enemyBulletY2 = new double[enemyBulletY.size()];
//				double[] enemyBulletW2 = new double[enemyBulletW.size()];
//				double[] enemyBulletH2 = new double[enemyBulletH.size()];
//				enemyBulletX2[i] = enemyBulletX.get(i);
//				enemyBulletY2[i] = enemyBulletY.get(i);
//				enemyBulletW2[i] = enemyBulletW.get(i);
//				enemyBulletH2[i] = enemyBulletH.get(i);
//				
//				if (enemyBulletX2[i] + enemyBulletW2[i] > 0 && enemyBulletX2[i] < 1000 && enemyBulletY2[i] + enemyBulletH2[i] > 0 && enemyBulletY2[i] < 650) {
//					at.rotate(-enemyBulletAimAngle.get(i), enemyBulletX2[i] + ((MudMukBullet.getWidth()*4)/2), enemyBulletY2[i] + ((MudMukBullet.getHeight()*4) /2));
//					g2d.transform(at);
//					g.drawImage(MudMukBullet, (int)enemyBulletX2[i], (int)enemyBulletY2[i], (int)enemyBulletW2[i], (int)enemyBulletH2[i], null);
//					
//					try{
//				        g2d.transform(at.createInverse());
//				    }catch(NoninvertibleTransformException e){
//				        //...
//				    }
//					
//					at.setToIdentity(); 
//				}
//				}
//			}
//	}
	
//	public void drawHealthUp(int x, int y, Graphics g) {
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y + 4, 4, 12);
//		g.fillRect(x + 4, y, 8, 4);
//		g.fillRect(x + 4, y + 16, 4, 4);
//		g.fillRect(x + 8, y + 20, 4, 4);
//		g.fillRect(x + 12, y + 4, 4, 4);
//		g.fillRect(x + 12, y + 24, 4, 4);
//		g.fillRect(x + 16, y, 8, 4);
//		g.fillRect(x + 16, y + 20, 4, 4);
//		g.fillRect(x + 20, y + 16, 4, 4);
//		g.fillRect(x + 24, y + 4, 4, 12);
//		g.setColor(Color.RED);
//		g.fillRect(x + 4, y + 4, 4, 12);
//		g.fillRect(x + 8, y + 4, 4, 16);
//		g.fillRect(x + 12, y + 8, 4, 16);
//		g.fillRect(x + 16, y + 4, 4, 16);
//		g.fillRect(x + 20, y + 4, 4, 12);
//		g.setColor(Color.WHITE);
//		g.fillRect(x + 20, y + 4, 4, 4);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
//		}
//	}
//
//	public void drawManaUp(int x, int y, Graphics g) {
//		g.setColor(Color.BLUE);
//		g.fillRect(x + 4, y + 4, 20, 20);
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y + 8, 4, 12);
//		g.fillRect(x + 4, y + 4, 4, 4);
//		g.fillRect(x + 4, y + 20, 4, 4);
//		g.fillRect(x + 8, y, 12, 4);
//		g.fillRect(x + 8, y + 24, 12, 4);
//		g.fillRect(x + 20, y + 4, 4, 4);
//		g.fillRect(x + 20, y + 20, 4, 4);
//		g.fillRect(x + 24, y + 8, 4, 12);
//		g.setColor(Color.WHITE);
//		g.fillRect(x + 16, y + 8, 4, 4);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.BLUE, g);
//		}
//	}
//	
//	public void drawDamageUp(int x, int y, Graphics g) {
//		g.setColor(Color.RED);
//		g.fillRect(x + 4, y + 4, 20, 20);
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y + 4, 4, 16);
//		g.fillRect(x + 4, y, 20, 4);
//		g.fillRect(x + 4, y + 12, 12, 4);
//		g.fillRect(x + 4, y + 20, 4, 8);
//		g.fillRect(x + 4, y + 24, 20, 4);
//		g.fillRect(x + 8, y, 4, 16);
//		g.fillRect(x + 16, y, 4, 12);
//		g.fillRect(x + 16, y + 8, 12, 4);
//		g.fillRect(x + 24, y + 4, 4, 16);
//		g.fillRect(x + 16, y + 16, 4, 4);
//		g.fillRect(x + 20, y + 20, 4, 4);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, Color.RED, g);
//		}
//	}
//	
//	public void drawDefenseUp(int x, int y, Graphics g) {
//		g.setColor(Color.BLACK);
//		g.fillRect(x, y, 4, 16);
//		g.fillRect(x, y, 32, 4);
//		g.fillRect(x + 4, y + 16, 4, 4);
//		g.fillRect(x + 8, y + 20, 4, 4);
//		g.fillRect(x + 12, y + 24, 8, 4);
//		g.fillRect(x + 20, y + 20, 4, 4);
//		g.fillRect(x + 24, y + 16, 4, 4);
//		g.fillRect(x + 28, y, 4, 16);
//		Color shieldShade = new Color(130, 130, 130);
//		g.setColor(shieldShade);
//		g.fillRect(x + 4, y + 4, 12, 12);
//		g.fillRect(x + 8, y + 16, 8, 4);
//		g.fillRect(x + 12, y + 20, 4, 4);
//		Color shield = new Color(201, 201, 201);
//		g.setColor(shield);
//		g.fillRect(x + 16, y + 20, 4, 4);
//		g.fillRect(x + 16, y + 16, 8, 4);
//		g.fillRect(x + 16, y + 4, 12, 12);
//		for (int i = 0; i < powerUp.size(); i++) {
//			drawPowerUpArrow(x + 24, y - 16, powerUpAnimation, shield, g);
//		}
//	}
	
	public void drawPowerUpArrow(int x, int y, int counter, Color color, Graphics g) {
		if (counter > 500 && counter < 1000) {
			y += 4;
		}
		g.setColor(Color.BLACK);
		g.fillRect(x, y + 8, 4, 4);
		g.fillRect(x + 4, y + 4, 4, 4);
		g.fillRect(x + 4, y + 12, 4, 12);
		g.fillRect(x + 8, y, 4, 4);
		g.fillRect(x + 8, y + 20, 4, 4);
		g.fillRect(x + 12, y + 4, 4, 4);
		g.fillRect(x + 12, y + 12, 4, 12);
		g.fillRect(x + 16, y + 8, 4, 4);
		g.setColor(color);
		g.fillRect(x + 4, y + 8, 12, 4);
		g.fillRect(x + 8, y + 4, 4, 16);
	}

	public void movement() {
		if (up == true) {
			if (player.getY() > barrierY) {
				barrierY++;
				player.setRealLocationY(-1 + player.getRealLocationY());
				movementTrackerY--;

				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, 1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, 1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(1 + powerUp.get(i).getY());
				}
			}
		}

		if (down == true) {
			// y++;
			if (player.getY() < barrierY + barrierH - 20) {
				barrierY--;
				//locationY++;
				player.setRealLocationY(1 + player.getRealLocationY());
				movementTrackerY++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setY(enemy.get(i).getY() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletY.set(i, -1 + enemyBulletY.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesY.set(i, -1 + gravesY.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setY(-1 + powerUp.get(i).getY());
				}
			}
		}
		if (left == true) {
			//x--;
			if (player.getX() > barrierX) {
				barrierX++;
				player.setRealLocationX(-1 + player.getRealLocationX());
				movementTrackerX--;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() + 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, 1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesY.size(); i++) {
					gravesX.set(i, 1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(1 + powerUp.get(i).getX());
				}
			}
		}
		if (right == true) {
			// x++;
			if (player.getX() < barrierX + barrierW - 20) {
				barrierX--;
				player.setRealLocationX(1 + player.getRealLocationX());
				movementTrackerX++;
				
				for (int i = 0; i < enemy.size(); i++) {
					enemy.get(i).setX(enemy.get(i).getX() - 1);
				}
//				for (int i = 0; i < enemyShot.size(); i++) {
//					enemyBulletX.set(i, -1 + enemyBulletX.get(i));
//				}
				for (int i = 0; i < gravesX.size(); i++) {
					gravesX.set(i, -1 + gravesX.get(i));
				}
				for (int i = 0; i < powerUp.size(); i++) {
					powerUp.get(i).setX(-1 + powerUp.get(i).getX());
				}
			}
		}

		for (int i = 0; i < playerShot.size(); i++) {
			if (up) {
				bulletY.set(i, 1 + bulletY.get(i));
			}
			if (down) {
				bulletY.set(i, -1 + bulletY.get(i));
			}
			if (left) {
				bulletX.set(i, 1 + bulletX.get(i));
			}
			if (right) {
				bulletX.set(i, -1 + bulletX.get(i));
			}
		}
	}

	public void shootingMechanic() {

		double angle = Math.atan2((player.getX() + 15) - mouseX, (player.getY() + 35) - mouseY);
		
		if (shooting == true) {
			shootingCounter++;
			if (shootingCounter == 1) {
				playerShot.add(true);
				bulletLife.add(950);
				bulletX.add((double) player.getX());
				bulletY.add((double) player.getY());
				bulletXAngle.add(Math.sin(angle));
				bulletYAngle.add(Math.cos(angle));
				bulletAimAngle.add(angle);
			}
			if (shootingCounter == 50)
				shootingCounter = 0;
		} else {
			shootingCounter = 0;
		}

		for (int i = 0; i < playerShot.size(); i++) {
			bulletLife.set(i, -5 + bulletLife.get(i));
			if (playerShot.get(i)) {
				bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
				bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
			}
			if (bulletLife.get(i) <= 0) {
				bulletCleanup(i);
			}
		}
		if (ability) {
			abilityMechanic();
		} else if (player.getMana() < 100) {
			player.setMana(player.getMana() + 0.025 + (manaUp * 0.00625));
		}
	}

	public void abilityMechanic() {
		player.setMana(0);;
		for (int i = 0; i < 30; i++) {
			double angle = Math.toRadians(0 + (i * 12));
			bulletXAngle.add(Math.sin(angle));
			bulletYAngle.add(Math.cos(angle));
			bulletAimAngle.add(angle);
			playerShot.add(true);
			bulletLife.add(950);
			bulletX.add((double) mouseX);
			bulletY.add((double) mouseY);
		}
		ability = false;
	}

	public void enemyLogic() {
//
		for (int i = 0; i < enemy.size(); i++) {
			
			enemy.get(i).movement(player.getX(), player.getY());
			
			enemy.get(i).aggro(player.getX(), player.getY(), 20, 20);
			
			for (int i2 = 0; i2 < playerShot.size(); i2++) {
				if (enemyHit(i, i2)) {
					bulletCleanup(i2);
					enemy.get(i).setHP((-(player.getAttack() * 2)) + enemy.get(i).getHP());
				}
			}
//			if (enemyAlive.size() > 0) {
//				enemyMovement(enemyX, enemyY, enemyW, enemyH, i);
//				predictiveAiming(i);
//			}
//
//			if (enemyAlive.size() > 100) {
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
			
			if (enemy.get(i).getHP() <= 0) {
				int rando = random.nextInt(23)+1;
				// should be a 25% chance to get a power up 
				switch (rando) {
					case 1 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Vitality"));
						break;
					}
					case 2 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Vitality"));
						break;
					}
					case 3 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Attack"));
						break;
					}
					case 4 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Attack"));
						break;
					}
					case 5 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Defense"));
						break;
					}
					case 6 : {
						powerUp.add(new PowerUp((int)enemy.get(i).getX(), (int)enemy.get(i).getY(), "Wisdom"));
						break;
					}
					default : {
						System.out.println("Nope, " + rando);
					}
				}
				enemy.remove(i);
				killCount++;
				System.out.println("Rando: " + rando);
			}
//
//			if (enemyHP.get(i) <= 0)
//				enemyAlive.set(i, false);
//			if (enemyAlive.get(i) == false) {
//					killCount++;
//					int powerUpSpawn = random.nextInt(11); //TODO
//					powerUp(powerUpSpawn, i);
//				enemyX.remove(i);
//				enemyY.remove(i);
//				enemyW.remove(i);
//				enemyH.remove(i);
//				enemyHP.remove(i);
//				enemyName.remove(i);
//				enemyShootingCounter.remove(i);
//				enemyDirectionCounter.remove(i);
//				storedX.remove(i);
//				storedY.remove(i);
//				storedX2.remove(i);
//				storedY2.remove(i);
//				predictiveAimAngle.remove(i);
//				enemyAlive.remove(i);
//			}
		}
	}

//	public void enemyMovement(ArrayList<Double> x, ArrayList<Double> y, ArrayList<Double> w, ArrayList<Double> h,
//			int i) {
//		if (enemyAlive.size() > enemyDirectionCounter.size()) {
//			enemyDirectionCounter.add(0);
//		}
//		enemyDirectionCounter.set(i, 1 + enemyDirectionCounter.get(i));
//		if (enemyDirectionCounter.get(i) == 1) {
//			int direction = random.nextInt(359);
//			double angle = direction;
//			double angle2 = Math.atan2((enemyX.get(i) + 85) - (this.x - 10), (y.get(i) + 70) - this.y);
//			if (movementAngleX.size() < enemyAlive.size()) {
//				movementAngleX.add(Math.sin(angle));
//				movementAngleY.add(Math.cos(angle));
//			} else {
////				if (playerAlive && x.get(i) < 1000 && y.get(i) < 650 && 0 < x.get(i) + w.get(i)
////						&& 0 < y.get(i) + h.get(i)) {
//					movementAngleX.set(i, (Math.sin(angle) + Math.sin(angle2)));
//					movementAngleY.set(i, (Math.cos(angle) + Math.cos(angle2)));
////				} else {
////					movementAngleX.set(i, Math.sin(angle));
////					movementAngleY.set(i, Math.cos(angle));
////				}
//			}
//		}
//		if (enemyDirectionCounter.get(i) < 50) {
//			x.set(i, x.get(i) - movementAngleX.get(i) * 0.125);
//			y.set(i, y.g et(i) - movementAngleY.get(i) * 0.125);
//		} else if (enemyDirectionCounter.get(i) >= 50) {
//			enemyDirectionCounter.set(i, 0);
//		}
//	}

	public boolean enemyHit(int i, int i2) {
		if (enemy.size() > 0) {
			if (bulletX.get(i2) < (enemy.get(i).getX() + 130.0) + 40.0 && enemy.get(i).getX() + 40.0 < bulletX.get(i2) + 10
					&& bulletY.get(i2) < (enemy.get(i).getY() + 130.0) + 10 && enemy.get(i).getY() < bulletY.get(i2) + 10) {
				return true;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}

	public void bulletCleanup(int i) {
		playerShot.remove(i);
		bulletLife.remove(i);
		bulletX.remove(i);
		bulletY.remove(i);
		bulletXAngle.remove(i);
		bulletYAngle.remove(i);
		bulletAimAngle.remove(i);
	}

//	public void enemyBulletLogic() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			double angle = Math.atan2((enemyX.get(i) + 85) - (x - 10), (enemyY.get(i) + 70) - y);
//			enemyShootingCounter.set(i, 1 + enemyShootingCounter.get(i));
//			if (enemyShootingCounter.get(i) == 400 && enemyName.get(i) == "SpyEye"
//					|| enemyShootingCounter.get(i) == 500 && enemyName.get(i) == "MudMuk"
//					|| enemyShootingCounter.get(i) == 450 && enemyName.get(i) == "Hugsbert"
//					|| enemyName.get(i) == "MadMask") {
//				if (enemyName.get(i) == "SpyEye") {
//					omnidirectionalPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MudMuk") {
//					shotgunPattern(angle, i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "Hugsbert") {
//					predictiveAimAngle.set(i, predictiveAim(x, y, enemyX.get(i), enemyY.get(i), angle, i));
//					shotgunPattern(predictiveAimAngle.get(i), i);
//					enemyShootingCounter.set(i, 0);
//				} else if (enemyName.get(i) == "MadMask") {
//					if (enemyShootingCounter.get(i) == 50 || enemyShootingCounter.get(i) == 100
//							|| enemyShootingCounter.get(i) == 150 || enemyShootingCounter.get(i) == 200
//							|| enemyShootingCounter.get(i) == 250)
//						genericPattern(angle, i);
//					else if (enemyShootingCounter.get(i) == 450)
//						enemyShootingCounter.set(i, 0);
//				}
//			}
//		}
//		for (int i2 = 0; i2 < enemyShooting.size(); i2++) {
//			bulletMovement(i2);
//		}
//	}

//	public void bulletMovement(int i) {
//		enemyBulletLife.set(i, -1 + enemyBulletLife.get(i));
//		enemyBulletX.set(i, enemyBulletX.get(i) - enemyBulletXAngle.get(i) * enemyBulletSpeed.get(i));
//		enemyBulletY.set(i, enemyBulletY.get(i) - enemyBulletYAngle.get(i) * enemyBulletSpeed.get(i));
//
//		if (enemyBulletLife.get(i) <= 0 || enemyShot.get(i) == false) {
//			enemyBulletOrigin.remove(i);
//			enemyBulletX.remove(i);
//			enemyBulletY.remove(i);
//			enemyBulletW.remove(i);
//			enemyBulletH.remove(i);
//			enemyBulletXAngle.remove(i);
//			enemyBulletYAngle.remove(i);
//			enemyBulletAimAngle.remove(i);
//			enemyBulletSpeed.remove(i);
//			enemyShooting.remove(i);
//			enemyShot.remove(i);
//			enemyBulletLife.remove(i);
//		}
//	}

	public double predictiveAim(int x, int y, double ex, double ey, double angle, int i) {
		double calculationX = ((storedX.get(i) - storedX2.get(i)) * -1) * 50;
		double calculationY = ((storedY.get(i) - storedY2.get(i)) * -1) * 50;
		// System.out.println(i + ": "+ storedX.get(i));
		// System.out.println((i+1) + ": "+ storedX.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationX);
		// System.out.println(i + ": "+ storedY.get(i));
		// System.out.println((i+1) + ": "+ storedY.get(i+1));
		// System.out.println(i + " + " + (i+1) + ": "+ calculationY);
		// System.out.println(calculationX + ", " + calculationY);
		angle = Math.atan2((ex + 85) - ((x - 10) + calculationX), (ey + 70) - ((y - 10) + calculationY));
		// System.out.println(Math.toDegrees(angle));
		return angle;
	}

//	public void predictiveAiming(int i) {
//		if (storedX.size() < enemyAlive.size()) {
//			storedX.add(i, (double) movementTrackerX);
//			storedY.add(i, (double) movementTrackerY);
//			storedX2.add(i, (double) movementTrackerX);
//			storedY2.add(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 445) {
//			storedX.set(i, (double) movementTrackerX);
//			storedY.set(i, (double) movementTrackerY);
//		}
//		if (enemyShootingCounter.get(i) == 449) {
//			storedX2.set(i, (double) movementTrackerX);
//			storedY2.set(i, (double) movementTrackerY);
//		}
//	}

//	public void genericPattern(double angle, int i) {
//		if (enemyName.get(i) == "MadMask") {
//			enemyShooting.add(true);
//			enemyShot.add(true);
//			enemyBulletOrigin.add("MadMask");
//			enemyBulletX.add(enemyX.get(i) + 59.5);
//			enemyBulletY.add(enemyY.get(i) + 63.5);
//			enemyBulletW.add(25.0);
//			enemyBulletH.add(25.0);
//			enemyBulletXAngle.add(Math.sin(angle));
//			enemyBulletYAngle.add(Math.cos(angle));
//			enemyBulletAimAngle.add(angle);
//			enemyBulletLife.add(500);
//			enemyBulletSpeed.add(2.0);
//		}
//	}

//	public void shotgunPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "MudMuk") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("MudMuk");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-25) + (Math.toRadians(12.5 * i2))));
//				enemyBulletSpeed.add(1.6);
//				enemyBulletLife.add(150);
//			}
//			if (enemyName.get(i) == "Hugsbert") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("Hugsbert");
//				enemyBulletX.add(enemyX.get(i) + 80);
//				enemyBulletY.add(enemyY.get(i) + 70);
//				enemyBulletW.add(20.0);
//				enemyBulletH.add(20.0);
//				enemyBulletXAngle.add(Math.sin(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletYAngle.add(Math.cos(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2)))));
//				enemyBulletAimAngle.add(angle + (Math.toRadians(-15) + (Math.toRadians(7.5 * i2))));
//				enemyBulletSpeed.add(1.75);
//				enemyBulletLife.add(250);
//			}
//			// TODO - figure out how to do predictive aim
//		}
//	}

//	public void omnidirectionalPattern(double angle, int i) {
//		for (int i2 = 0; i2 < 5; i2++) {
//			if (enemyName.get(i) == "SpyEye") {
//				enemyShooting.add(true);
//				enemyShot.add(true);
//				enemyBulletOrigin.add("SpyEye");
//				enemyBulletX.add(enemyX.get(i) + 90);
//				enemyBulletY.add(enemyY.get(i) + 65);
//				enemyBulletW.add(30.0);
//				enemyBulletH.add(30.0);
//				enemyBulletXAngle.add(Math.sin(angle + Math.toRadians(72 * i2)));
//				enemyBulletYAngle.add(Math.cos(angle + Math.toRadians(72 * i2)));
//				enemyBulletAimAngle.add(angle + Math.toRadians(72 * i2));
//				enemyBulletSpeed.add(2.5);
//				enemyBulletLife.add(200);
//			}
//		}
//	}

//	public void bulletCollision() {
//		for (int i = 0; i < enemyAlive.size(); i++) {
//			for (int i2 = i * 5; i2 >= i * 5 && i2 < (i * 5) + 5 && i2 < enemyShooting.size(); i2++) {
//				if (enemyBulletX.get(i2) < x + 20 && x < enemyBulletX.get(i2) + enemyBulletW.get(i2)
//						&& enemyBulletY.get(i2) < y + 20 && y < enemyBulletY.get(i2) + enemyBulletH.get(i2)) {
//					if (enemyName.get(i) == "SpyEye") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MudMuk") {
//						if ((defenseUp / 4) < 2) {
//							playerHP -= 2 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "Hugsbert") {
//						if ((defenseUp / 4) < 10) {
//							playerHP -= 10 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					} else if (enemyName.get(i) == "MadMask") {
//						if ((defenseUp / 4) < 5) {
//							playerHP -= 5 - (defenseUp / 4);
//						} else
//							playerHP -= 1;
//					}
//					enemyShot.set(i2, false);
//				}
//			}
//		}
//	}

//	public void powerUp(int spawnRate, int i) {
//
//		if (spawnRate == 0 || spawnRate == 1) {
//			powerUp.add(true);
//			powerUpType.add("Health");
//		} else if (spawnRate == 2 || spawnRate == 3) {
//			powerUp.add(true);
//			powerUpType.add("Mana");
//		} else if (spawnRate == 4) {
//			powerUp.add(true);
//			powerUpType.add("Damage");
//		} else if (spawnRate == 5) {
//			powerUp.add(true);
//			powerUpType.add("Defense");
//		}
//		for (int i2 = 0; i2 < powerUp.size(); i2++) {
//			if (powerUp.get(i2) && powerUp.size() > powerUpX.size() && i2 == powerUpX.size()) {
//				int[] enemyX2 = new int[enemyX.size()];
//				int[] enemyY2 = new int[enemyY.size()];
//				enemyX2[i] += enemyX.get(i) + (enemyW.get(i) / 2) - 12;
//				enemyY2[i] += enemyY.get(i) + (enemyH.get(i) / 2) - 12;
//				powerUpX.add(enemyX2[i]);
//				powerUpY.add(enemyY2[i]);
//				// if (powerUp.get(i2) == false) {
//				// powerUpX.remove(i2);
//				// powerUpY.remove(i2);
//				// powerUp.remove(i2);
//				// }
//			}
//		}
//	}

//	public boolean powerUpCollected(int i) {
//		if (x < powerUpX.get(i) + 44 && y < powerUpY.get(i) + 24 && powerUpX.get(i) < x + 24
//				&& powerUpY.get(i) < y + 20) {
//			return true;
//		} else {
//			return false;
//		}
//	}
	
	public void paintComponent(Graphics g) {
		super.paintComponent(g);
		
		Graphics2D g2d = (Graphics2D)g;
		
//		drawPowerUpArrow(500, 10, powerUpAnimation, (Color.RED), g);
		
		powerUpAnimation++;
		if (powerUpAnimation == 1000)
			powerUpAnimation = 0;
		for (int i = 0; i < powerUp.size(); i++) {
			powerUp.get(i).draw(g);
//			if (powerUpType.get(i) == "Health")
//				drawHealthUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Mana")
//				drawManaUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Damage")
//				drawDamageUp(powerUpX.get(i), powerUpY.get(i), g);
//			else if (powerUpType.get(i) == "Defense")
//				drawDefenseUp(powerUpX.get(i), powerUpY.get(i), g);
		}

		drawPreviousDeaths(g);

		g.drawRect(barrierX, barrierY, barrierW, barrierH);

		
		
		drawEnemies(g);
//		
//		for (int i = 0; i < enemyName.size(); i++) {
//			if (enemyName.get(i) == "MadMask") {
//				drawMadMaskBullets(g, g2d);
//			} else if (enemyName.get(i) == "SpyEye") {
//				drawSpyEyeBullets(g, g2d);
//			} else if (enemyName.get(i) == "Hugsbert") {
//				drawHugsbertBullets(g, g2d);
//			} else {
//				drawMudMukBullets(g, g2d);
//			}
//		}

		if (playerAlive) {
			player.draw(g);
		} else {
			drawDeadPlayer(player.getX(), player.getY(), g);
		}

		g.drawString("Personal Best: " + hiScore, 10, 20);
		g.drawString("Kill Count: " + killCount, 10, 40);

		g.drawString("Enemies Alive: " + enemy.size(), 10, 65);
		g.drawString("Regen: " + player.getVitality(), 10, 85);
		g.drawString("Mana Regen: " + player.getWisdom(), 10, 105);
		g.drawString("Damage: " + player.getAttack(), 10, 125);
		g.drawString("Defense: " + player.getDefense(), 10, 145);
		
		drawBullets(g, g2d);
	}
	
	@Override
	public void actionPerformed(ActionEvent e) {
		
		spawning();
		
//		if (manaUp > 20) manaUp = 20; // mana cap
		
		// increases the rate at which the player heals
		regen++;
		if (regen > (1000 - (player.getVitality() * 5)) && player.getHP() < 100) {
			player.setHP(2 + player.getHP());
			regen = 0;
		}
		if (player.getHP() > 100) {
			player.setHP(100);
		}
		for (int i = 0; i < powerUp.size(); i++) {
			if (powerUp.get(i).collected(player.getX(), player.getY(), player.getW(), player.getH())) {
				player.collectPowerUp(powerUp.get(i).getType());
				
				powerUp.remove(i);
			}
		}

		if (player.getHP() <= 0) {
			playerAlive = false;
		}

		if (playerAlive) {
			movement();
			shootingMechanic();
//			bulletCollision();
		} else {
			for (int i = 0; i < playerShot.size(); i++) {
				bulletLife.set(i, -5 + bulletLife.get(i));
				if (playerShot.get(i)) {
					bulletX.set(i, bulletX.get(i) - bulletXAngle.get(i) * 2.5);
					bulletY.set(i, bulletY.get(i) - bulletYAngle.get(i) * 2.5);
				}
				if (bulletLife.get(i) <= 0) {
					bulletCleanup(i);
				}
			}
			try {
				recordDeath(player.getRealLocationX(), player.getRealLocationY());
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
		}

		enemyLogic();
//		enemyBulletLogic();
		
		try {
			highScoreWriter(hiScore);
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		

		repaint();
	}

	public void keyPressed(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = true;
		}
		if (key == 'A') {
			left = true;
		}
		if (key == 'S') {
			down = true;
		}
		if (key == 'D') {
			right = true;
		}
		if (key == KeyEvent.VK_SPACE && player.getMana() >= 100) {
			ability = true;
		}
	}
	public void keyReleased(KeyEvent e) {
		int key = e.getKeyCode();
		if (key == KeyEvent.VK_W) {
			up = false;
		}
		if (key == 'A') {
			left = false;
		}
		if (key == 'S') {
			down = false;
		}
		if (key == 'D') {
			right = false;
		}
		if (key == KeyEvent.VK_SPACE && player.getMana() == 100) {
			ability = false;
		}
	}

	@Override
	public void mouseClicked(MouseEvent e) {
	}
	@Override
	public void mousePressed(MouseEvent e) {
		shooting = true;
	}
	@Override
	public void mouseReleased(MouseEvent e) {
		shooting = false;
	}
	@Override
	public void mouseDragged(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseMoved(MouseEvent e) {
		mouseX = e.getX();
		mouseY = e.getY();
	}
	@Override
	public void mouseEntered(MouseEvent e) {

	}
	@Override
	public void mouseExited(MouseEvent e) {

	}

	private void initComponents() {
		javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
		this.setLayout(layout);
		layout.setHorizontalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 400, Short.MAX_VALUE));
		layout.setVerticalGroup(
				layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING).addGap(0, 300, Short.MAX_VALUE));
	}

}
----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-02-02 19:23:29.547
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-02-02 19:23:29.552
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.ASTNode.setSourceRange(ASTNode.java:3008)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToFieldDeclaration(ASTConverter.java:3378)
	at org.eclipse.jdt.core.dom.ASTConverter.checkAndAddMultipleFieldDeclaration(ASTConverter.java:456)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:198)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3115)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1439)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:392)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:268)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1138)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:736)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:802)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1315)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:92)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-02-03 13:17:08.235 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-02-03 13:17:15.264
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2021-02-03 13:17:41.149
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-04 10:04:22.466 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-02-04 10:04:33.899
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.egit.ui 2 0 2021-02-04 10:05:14.324
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-09 13:10:50.474 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-09 13:11:31.921
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug 2 0 2021-02-09 14:12:45.980
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2021-02-09 14:13:05.958
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.jdt.debug 2 0 2021-02-09 14:13:32.336
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread

!ENTRY org.eclipse.ui 4 4 2021-02-09 21:41:36.193
!MESSAGE To avoid deadlock while executing Display.syncExec() with argument: org.eclipse.debug.internal.ui.sourcelookup.Prompter$$Lambda$677/719213363@d98135a, thread Worker-170: Launching Oryx (1) will interrupt UI thread.
!SUBENTRY 1 org.eclipse.ui 4 4 2021-02-09 21:41:36.193
!MESSAGE Worker-170: Launching Oryx (1) thread is an instance of Worker or owns an ILock
!STACK 0
java.lang.IllegalStateException: Call stack for thread Worker-170: Launching Oryx (1)
	at sun.management.ThreadImpl.dumpThreads0(Native Method)
	at sun.management.ThreadImpl.getThreadInfo(Unknown Source)
	at org.eclipse.ui.internal.UILockListener.reportInterruption(UILockListener.java:209)
	at org.eclipse.ui.internal.UILockListener.interruptUI(UILockListener.java:179)
	at org.eclipse.ui.internal.PendingSyncExec.waitUntilExecuted(PendingSyncExec.java:92)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:155)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4622)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.handleStatus(Prompter.java:81)
	at org.eclipse.debug.core.model.LaunchConfigurationDelegate.saveBeforeLaunch(LaunchConfigurationDelegate.java:246)
	at org.eclipse.debug.core.model.LaunchConfigurationDelegate.preLaunchCheck(LaunchConfigurationDelegate.java:198)
	at org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate.preLaunchCheck(AbstractJavaLaunchConfigurationDelegate.java:1020)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:823)
	at org.eclipse.debug.internal.core.LaunchConfiguration.launch(LaunchConfiguration.java:719)
	at org.eclipse.debug.internal.ui.DebugUIPlugin.buildAndLaunch(DebugUIPlugin.java:1017)
	at org.eclipse.debug.internal.ui.DebugUIPlugin$2.run(DebugUIPlugin.java:1220)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SUBENTRY 1 org.eclipse.ui 4 4 2021-02-09 21:41:36.196
!MESSAGE UI thread waiting on a job or lock.
!STACK 0
java.lang.IllegalStateException: Call stack for thread main
	at java.io.WinNTFileSystem.getBooleanAttributes(Native Method)
	at java.io.File.exists(Unknown Source)
	at java.io.WinNTFileSystem.canonicalize(Unknown Source)
	at java.io.File.getCanonicalPath(Unknown Source)
	at org.eclipse.osgi.storage.Storage.getFile(Storage.java:1045)
	at org.eclipse.osgi.storage.Storage.getFile(Storage.java:1017)
	at org.eclipse.osgi.storage.BundleInfo$Generation.getExtractFile(BundleInfo.java:340)
	at org.eclipse.osgi.storage.bundlefile.CloseableBundleFile.getExtractFile(CloseableBundleFile.java:174)
	at org.eclipse.osgi.storage.bundlefile.CloseableBundleFile.getFile(CloseableBundleFile.java:188)
	at org.eclipse.osgi.storage.bundlefile.ZipBundleEntry.getFileURL(ZipBundleEntry.java:107)
	at org.eclipse.osgi.storage.url.BundleURLConnection.getFileURL(BundleURLConnection.java:139)
	at org.eclipse.osgi.storage.url.BundleURLConverter.toFileURL(BundleURLConverter.java:38)
	at org.eclipse.core.runtime.FileLocator.toFileURL(FileLocator.java:261)
	at org.eclipse.jface.resource.URLImageDescriptor.getFilePath(URLImageDescriptor.java:232)
	at org.eclipse.jface.resource.URLImageDescriptor.access$2(URLImageDescriptor.java:220)
	at org.eclipse.jface.resource.URLImageDescriptor$URLImageFileNameProvider.getImagePath(URLImageDescriptor.java:57)
	at org.eclipse.swt.internal.DPIUtil.validateAndGetImagePathAtZoom(DPIUtil.java:419)
	at org.eclipse.swt.graphics.Image.<init>(Image.java:687)
	at org.eclipse.jface.resource.URLImageDescriptor.createImage(URLImageDescriptor.java:263)
	at org.eclipse.jface.resource.ImageDescriptor.createResource(ImageDescriptor.java:182)
	at org.eclipse.jface.resource.DeviceResourceManager.allocate(DeviceResourceManager.java:55)
	at org.eclipse.jface.resource.AbstractResourceManager.create(AbstractResourceManager.java:88)
	at org.eclipse.jface.resource.ResourceManager.createImageWithDefault(ResourceManager.java:195)
	at org.eclipse.jface.resource.ImageRegistry.get(ImageRegistry.java:206)
	at org.eclipse.ui.internal.progress.ProgressManager.getIconFor(ProgressManager.java:1000)
	at org.eclipse.ui.internal.progress.ProgressInfoItem.getInfoImage(ProgressInfoItem.java:338)
	at org.eclipse.ui.internal.progress.ProgressInfoItem.createChildren(ProgressInfoItem.java:208)
	at org.eclipse.ui.internal.progress.ProgressInfoItem.<init>(ProgressInfoItem.java:196)
	at org.eclipse.ui.internal.progress.DetailedProgressViewer.createNewItem(DetailedProgressViewer.java:212)
	at org.eclipse.ui.internal.progress.DetailedProgressViewer.refreshAll(DetailedProgressViewer.java:449)
	at org.eclipse.ui.internal.progress.DetailedProgressViewer.inputChanged(DetailedProgressViewer.java:345)
	at org.eclipse.jface.viewers.ContentViewer.setInput(ContentViewer.java:282)
	at org.eclipse.jface.viewers.StructuredViewer.setInput(StructuredViewer.java:1627)
	at org.eclipse.ui.internal.progress.BlockedJobsDialog.showJobDetails(BlockedJobsDialog.java:235)
	at org.eclipse.ui.internal.progress.BlockedJobsDialog.createDialogArea(BlockedJobsDialog.java:214)
	at org.eclipse.jface.dialogs.IconAndMessageDialog.createDialogAndButtonArea(IconAndMessageDialog.java:227)
	at org.eclipse.jface.dialogs.IconAndMessageDialog.createContents(IconAndMessageDialog.java:206)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.jface.window.Window.open(Window.java:788)
	at org.eclipse.ui.internal.progress.BlockedJobsDialog$1.runInUIThread(BlockedJobsDialog.java:160)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.ui.progress.UIJob$$Lambda$429/791456254.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3961)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3588)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.runEventLoop(EventLoopProgressMonitor.java:127)
	at org.eclipse.ui.internal.dialogs.EventLoopProgressMonitor.isCanceled(EventLoopProgressMonitor.java:101)
	at org.eclipse.core.internal.jobs.ThreadJob.isCanceled(ThreadJob.java:147)
	at org.eclipse.core.internal.jobs.ThreadJob.waitForRun(ThreadJob.java:276)
	at org.eclipse.core.internal.jobs.ThreadJob.joinRun(ThreadJob.java:205)
	at org.eclipse.core.internal.jobs.ImplicitJobs.begin(ImplicitJobs.java:95)
	at org.eclipse.core.internal.jobs.JobManager.beginRule(JobManager.java:297)
	at org.eclipse.core.internal.resources.WorkManager.checkIn(WorkManager.java:124)
	at org.eclipse.core.internal.resources.Workspace.prepareOperation(Workspace.java:2243)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2290)
	at org.eclipse.core.internal.resources.Workspace.run(Workspace.java:2322)
	at org.eclipse.ui.actions.WorkspaceModifyOperation.run(WorkspaceModifyOperation.java:131)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:76)
	at org.eclipse.ui.internal.editors.text.WorkspaceOperationRunner.run(WorkspaceOperationRunner.java:66)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.executeOperation(TextFileDocumentProvider.java:461)
	at org.eclipse.ui.editors.text.TextFileDocumentProvider.validateState(TextFileDocumentProvider.java:1037)
	at org.eclipse.ui.texteditor.AbstractTextEditor.validateState(AbstractTextEditor.java:4951)
	at org.eclipse.jdt.internal.ui.javaeditor.CompilationUnitEditor.doSave(CompilationUnitEditor.java:1322)
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.doSave(AbstractTextEditor.java:7182)
	at org.eclipse.ui.Saveable.doSave(Saveable.java:213)
	at org.eclipse.ui.internal.SaveableHelper.doSaveModel(SaveableHelper.java:333)
	at org.eclipse.ui.internal.SaveablesList.lambda$2(SaveablesList.java:850)
	at org.eclipse.ui.internal.SaveablesList$$Lambda$678/2107018945.run(Unknown Source)
	at org.eclipse.ui.internal.SaveableHelper.lambda$3(SaveableHelper.java:271)
	at org.eclipse.ui.internal.SaveableHelper$$Lambda$679/465469387.run(Unknown Source)
	at org.eclipse.jface.operation.ModalContext.runInCurrentThread(ModalContext.java:436)
	at org.eclipse.jface.operation.ModalContext.run(ModalContext.java:352)
	at org.eclipse.ui.internal.WorkbenchWindow.lambda$5(WorkbenchWindow.java:2368)
	at org.eclipse.ui.internal.WorkbenchWindow$$Lambda$642/1791935649.run(Unknown Source)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:72)
	at org.eclipse.ui.internal.WorkbenchWindow.run(WorkbenchWindow.java:2366)
	at org.eclipse.ui.internal.SaveableHelper.runProgressMonitorOperation(SaveableHelper.java:278)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:858)
	at org.eclipse.ui.internal.SaveablesList.saveModels(SaveablesList.java:822)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3451)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1495)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1483)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter$$Lambda$677/719213363.run(Unknown Source)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.ui.internal.UISynchronizer.lambda$0(UISynchronizer.java:152)
	at org.eclipse.ui.internal.UISynchronizer$$Lambda$453/288524271.run(Unknown Source)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:3961)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3588)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1160)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1049)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:633)
	at org.eclipse.ui.internal.Workbench$$Lambda$26/2078741622.run(Unknown Source)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:557)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:150)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:150)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:137)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:107)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:400)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
	at java.lang.reflect.Method.invoke(Unknown Source)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:660)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:597)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1468)
!SESSION 2021-02-11 06:04:55.229 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-11 06:05:42.105
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-12 12:52:40.874 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-12 12:53:37.747
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-16 12:59:21.431 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-16 13:00:32.216
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.debug 2 0 2021-02-16 13:35:18.983
!MESSAGE Unable to find location of java.lang.Thread.setName() in debuggee JVM, for type java.lang.Thread
!SESSION 2021-02-16 13:41:08.549 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-16 13:41:45.303
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-16 13:51:39.515 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-16 13:51:53.518
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-16 14:32:11.865 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data file:/C:/Users/battl/eclipse-workspace/ -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-16 14:32:28.817
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-16 14:34:05.704 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-16 14:34:14.387
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-16 14:57:43.539 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data file:/C:/Users/battl/eclipse-workspace/ -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-16 14:58:12.254
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-16 15:18:53.847 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-16 15:20:09.402
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-17 12:27:23.917 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-17 12:28:09.421
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-18 08:47:23.212 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-18 08:48:09.723
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-18 09:16:39.991 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-18 09:16:51.154
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-18 11:20:15.902 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-18 11:20:31.535
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-18 16:01:06.801 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-18 16:01:54.696
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-18 21:26:10.953 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-18 21:26:35.794
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-23 13:03:04.196 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-23 13:03:43.809
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-23 13:40:19.594 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product -data C:\Users\battl\eclipse-workspace -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-23 13:40:29.721
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-23 14:31:28.083 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-23 14:31:37.695
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-24 08:56:40.609 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-24 08:57:44.113
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-24 12:17:16.641 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-24 12:17:45.964
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-24 12:22:59.491 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-24 12:23:08.613
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-24 15:31:39.916 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-24 15:31:59.485
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-25 11:09:32.247 -----------------------------------------------
eclipse.buildId=4.13.0.I20190916-1045
java.version=1.8.0_221
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_CA
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.egit.ui 2 0 2021-02-25 11:10:26.384
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\battl'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 4 567 2021-02-25 11:20:14.498
!MESSAGE The project description file (.project) for 'Project Caliburn 2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'Project Caliburn 2' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:907)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1056)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1102)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
